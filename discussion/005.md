<!-- Comment 005 - 2025-12-29T13:01:13+01:00 -->

## Implementation Plan: Schema in DLog with Dual Index Migration

### Core Design Principles

1. **Schema is data** - Schema entries are commits in the log, not external config
2. **Schema changes are snapshots** - Every schema change occurs at a snapshot boundary
3. **Schemaless by default** - No schema means accept everything
4. **At most one pending schema** - Simplifies migration state machine

---

### Data Model

#### DLog Entry Extension

```go
type Entry struct {
    Commit     int64
    Timestamp  string
    ScopeID    *string
    
    // Exactly one of these is set:
    Patch        *ir.Node      // Data change
    SchemaEntry  *SchemaEntry  // Schema change (always with snapshot)
}

type SchemaEntry struct {
    Schema  *ir.Node  // Tony schema document (nil = schemaless)
    Status  string    // "pending" | "active" | "aborted"
}
```

#### Snapshot Header Extension

```go
type SnapshotHeader struct {
    Commit  int64
    Schema  *ir.Node  // Schema active from this snapshot forward
}
```

#### Storage State

```go
type Storage struct {
    // Active schema (from most recent active snapshot)
    activeSchema       *ir.Node
    activeSchemaCommit int64
    
    // Pending migration (nil if none)
    pendingSchema       *ir.Node
    pendingSchemaCommit int64
    pendingIndex        *index.Index
    
    // Primary index (uses active schema)
    index *index.Index
}
```

---

### Schema Lifecycle

#### State Machine

```
[schemaless] --set--> [active v1] --pending--> [active v1 + pending v2] --complete--> [active v2]
                          ^                            |
                          |                            v
                          +----------- abort ----------+
```

#### Commit Sequence Example

```
Commit 1:   snapshot, schema=nil (schemaless)
Commit 2-50: data patches
Commit 51:  snapshot, SchemaEntry{schema=v1, status="active"}
Commit 52-99: data patches (indexed under v1)
Commit 100: snapshot, SchemaEntry{schema=v2, status="pending"}
            → creates pendingIndex, re-indexes 51-99 under v2
Commit 101-149: data patches (dual-indexed: v1 and v2)
Commit 150: snapshot, SchemaEntry{schema=v2, status="active"}
            → switches pendingIndex to index, clears pending state
Commit 151+: data patches (indexed under v2)
```

---

### Wire Protocol

```go
type SchemaRequest struct {
    Get      *struct{}           // Get current schema state
    Set      *SchemaSetRequest   // Set schema (pending or active)
}

type SchemaSetRequest struct {
    Schema  *ir.Node  // New schema (nil = schemaless)
    Pending bool      // true = start migration, false = immediate (first schema only)
}

type SchemaResult struct {
    Active        *ir.Node
    ActiveCommit  int64
    Pending       *ir.Node  // nil if no pending migration
    PendingCommit int64
}

type MigrationRequest struct {
    Complete *struct{}  // Finalize: pending becomes active
    Abort    *struct{}  // Cancel: discard pending
}
```

---

### Operations

#### Set Initial Schema (no prior schema)

```go
func (s *Storage) SetInitialSchema(schema *ir.Node) error {
    if s.activeSchema != nil {
        return ErrSchemaAlreadySet
    }
    // Triggers snapshot with SchemaEntry{status: "active"}
    return s.commitSchemaChange(schema, "active")
}
```

#### Start Migration

```go
func (s *Storage) StartMigration(newSchema *ir.Node) error {
    if s.pendingSchema != nil {
        return ErrMigrationInProgress
    }
    
    // 1. Snapshot current state (closes current schema span)
    // 2. Write SchemaEntry{status: "pending"}
    // 3. Create pendingIndex
    // 4. Re-index from activeSchemaCommit to now under new schema
    
    return s.commitSchemaChange(newSchema, "pending")
}
```

#### Complete Migration

```go
func (s *Storage) CompleteMigration() error {
    if s.pendingSchema == nil {
        return ErrNoMigrationInProgress
    }
    
    // 1. Snapshot with SchemaEntry{status: "active"}
    // 2. Swap: index = pendingIndex
    // 3. Clear pending state
    
    return s.commitSchemaChange(s.pendingSchema, "active")
}
```

#### Abort Migration

```go
func (s *Storage) AbortMigration() error {
    if s.pendingSchema == nil {
        return ErrNoMigrationInProgress
    }
    
    // 1. Write SchemaEntry{status: "aborted"} (no snapshot needed)
    // 2. Discard pendingIndex
    // 3. Clear pending state
    
    return s.commitSchemaChange(nil, "aborted")
}
```

---

### Write Path

```go
func (s *Storage) WriteAndIndex(entry *dlog.Entry) error {
    // Always index to active
    s.indexPatch(s.index, s.activeSchema, entry)
    
    // Also index to pending if migration in progress
    if s.pendingIndex != nil {
        s.indexPatch(s.pendingIndex, s.pendingSchema, entry)
    }
    
    return nil
}
```

---

### Log Replay

```go
func (s *Storage) replayEntry(entry *dlog.Entry) error {
    if entry.SchemaEntry != nil {
        return s.replaySchemaEntry(entry)
    }
    return s.replayDataEntry(entry)
}

func (s *Storage) replaySchemaEntry(entry *dlog.Entry) error {
    se := entry.SchemaEntry
    switch se.Status {
    case "pending":
        s.pendingSchema = se.Schema
        s.pendingSchemaCommit = entry.Commit
        s.pendingIndex = index.New()
        // Re-index [activeSchemaCommit, entry.Commit) into pendingIndex
        s.reindexForPending()
        
    case "active":
        if s.pendingIndex != nil {
            // Migration complete
            s.index = s.pendingIndex
            s.pendingIndex = nil
        }
        s.activeSchema = se.Schema
        s.activeSchemaCommit = entry.Commit
        s.pendingSchema = nil
        
    case "aborted":
        s.pendingSchema = nil
        s.pendingSchemaCommit = 0
        s.pendingIndex = nil
    }
    return nil
}
```

---

### Query Path

Schema lookup uses snapshot boundaries:

```go
func (s *Storage) schemaForCommit(commit int64) *ir.Node {
    // Find most recent snapshot with schema <= commit
    // Snapshots are the only places schema can change
}
```

For current reads, just use `s.activeSchema`.

---

### Scope Interaction

Scopes can opt-in to pending schema for testing:

```go
type Hello struct {
    ClientID   string
    Scope      *string
    UsePending bool  // If true, reads use pendingIndex
}
```

Sessions bound to pending get `ErrSchemaMigrationAborted` if migration is aborted.

---

### Implementation Phases

#### Phase 1: Schema Entry Type
- Add `SchemaEntry` to `dlog.Entry`
- Add schema field to snapshot header
- Storage tracks `activeSchema`, `activeSchemaCommit`

#### Phase 2: Initial Schema Support
- Wire protocol for `SchemaRequest.Set` (non-pending)
- `SetInitialSchema` implementation
- Schema in `HelloResponse`

#### Phase 3: Pending Migration Infrastructure
- Add `pendingSchema`, `pendingIndex` to storage
- `StartMigration` creates pending state
- Dual-write path for data entries

#### Phase 4: Re-indexing
- Implement `reindexForPending`
- Iterate commits from `activeSchemaCommit` to current
- Index into `pendingIndex` under `pendingSchema`

#### Phase 5: Migration Completion
- `CompleteMigration` swaps indexes
- `AbortMigration` discards pending
- Wire protocol for `MigrationRequest`

#### Phase 6: Log Replay
- Handle schema entries during replay
- Reconstruct pending state if replay ends mid-migration

#### Phase 7: Scope Binding
- `UsePending` in Hello
- Session schema staleness detection

---

### Files to Modify

| File | Changes |
|------|---------|
| `storage/internal/dlog/entry.go` | Add `SchemaEntry` |
| `storage/snap_storage.go` | Schema in snapshot header |
| `storage/storage.go` | Schema state, pending index |
| `storage/commit_ops.go` | Dual write path |
| `storage/replay.go` | Schema entry handling |
| `api/session.go` | Schema/Migration request types |
| `server/session.go` | Handle schema requests |

