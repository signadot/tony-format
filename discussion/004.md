<!-- Comment 004 - 2026-01-04T23:06:35+01:00 -->

## Revised Thinking: Correlation Controller, Not Capture

After further discussion, the proxy-based capture approach may be over-engineered given existing capabilities.

### Existing Traffic Capture

Signadot already provides traffic capture for debugging:
- `signadot traffic record --sandbox ...` captures live traffic
- TUI-based live traffic browser for developers
- Works for any service/workload running in-cluster

Other proxies (Helicone, Portkey, etc.) already solve LLM API capture.

**Limitation**: Signadot traffic capture works for in-cluster services/workloads. If MCP servers run outside the cluster (local stdio, external services), they won't be captured this way.

### Where the Value-Add Is

Traffic capture is a known space. The novel contribution would be a **Correlation Controller** that:

1. Consumes existing traffic streams (Signadot for in-cluster tools, other proxies for LLM)
2. Correlates LLM traffic with tool traffic via `tool_use_id`
3. Emits a unified "agent conversation" view in real-time

```
LLM Stream (from existing proxy)     Tool Stream (from Signadot)
            │                                    │
            └──────────► Correlation ◄───────────┘
                         Controller
                              │
                              ▼
                    Unified Agent View
                    (live watch + storage)
```

### Why This Is a Controller

- **Computed view**: joins two independent streams by correlation ID
- **Watch-primary**: main interface is real-time `tonyapi watch /live/conversations/{id}`
- **Stateful**: maintains pending tool_use_id mappings across async events
- **Not storage**: reads from existing sources, optionally persists correlated result

### Example Output

```bash
tonyapi watch /live/conversations/conv-123

turn: 1
  user: "Fix the bug in auth.go"
  assistant: [tool_use: read_file]
    └─► read_file(auth.go) → [850 lines] (23ms)
  assistant: "I see the issue on line 42..."
  assistant: [tool_use: edit_file]
    └─► edit_file(auth.go, ...) → success (15ms)
  assistant: [tool_use: bash]  
    └─► bash(go test) → PASS (1.2s)
  assistant: "All tests pass."
```

### Implications

- **LLM Proxy**: probably not needed if customer already uses Helicone/Portkey/etc., or we integrate with their capture
- **MCP Proxy**: only needed for out-of-cluster MCP servers (stdio-based, local)
- **Correlation Controller**: the differentiator - makes two streams intelligible as "an agent working"

This positions the work as building on existing infrastructure (Signadot traffic, third-party LLM proxies) rather than rebuilding capture from scratch.

