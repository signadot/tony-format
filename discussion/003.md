<!-- Comment 003 - 2025-12-22T19:55:33+01:00 -->

## Design Decision: OpContext for Schema-Aware Matching

After exploration, we've settled on **Option B** with a unified context design.

### Problem

`tony.Match` doesn't know about schema definitions. After expanding `.[defname]` references, the matcher encounters unknown tags (like `!string` from definition substitution) or unexpanded `.[ref]` strings (from cycles), and fails.

### Solution: Unified OpContext

A single context type that carries both schema resolution AND behavioral options:

```go
// mergeop/context.go

type OpContext struct {
    // === Schema Resolution ===
    
    // DefEnv maps definition names to bodies for .[ref] expansion
    DefEnv map[string]any
    
    // EvalOpts for parameterized definition handling
    EvalOpts *eval.EvalOptions
    
    // SchemaRegistry for cross-schema !from(schema,def) references
    SchemaRegistry *schema.SchemaRegistry
    
    // expanding tracks definitions being expanded (cycle detection, internal)
    expanding map[string]bool
    
    // === Behavioral Options ===
    
    // Comments controls whether comments are processed
    Comments bool
    
    // Tags controls whether tags must match exactly
    Tags bool
}
```

### Updated Signatures

```go
type MatchFunc func(doc, pattern *ir.Node, ctx *OpContext) (bool, error)
type PatchFunc func(doc, patch *ir.Node, ctx *OpContext) (*ir.Node, error)
type DiffFunc  func(from, to *ir.Node, ctx *OpContext) *ir.Node

type Op interface {
    Match(doc *ir.Node, ctx *OpContext, f MatchFunc) (bool, error)
    Patch(doc *ir.Node, ctx *OpContext, mf MatchFunc, pf PatchFunc, df DiffFunc) (*ir.Node, error)
    String() string
}
```

### Backward-Compatible API

```go
// Current API preserved
func Match(doc, pattern *ir.Node) (bool, error)
func Patch(doc, patch *ir.Node) (*ir.Node, error)
func Diff(from, to *ir.Node) *ir.Node

// New context-aware API
func MatchWith(doc, pattern *ir.Node, ctx *OpContext) (bool, error)
func PatchWith(doc, patch *ir.Node, ctx *OpContext) (*ir.Node, error)
func DiffWith(from, to *ir.Node, ctx *OpContext) *ir.Node
```

### Key Behaviors

1. **Recursive expansion with cycle detection**: When expanding `.[ref]`, track in `ctx.expanding`. If cycle detected, leave unexpanded for lazy resolution.

2. **Lazy resolution in matching**: When `MatchWith` encounters an unexpanded `.[ref]` string, expand on-demand using `ctx.DefEnv`.

3. **Ops can access context**: Mergeops that need schema awareness (e.g., future `!validate`, `!typedef`) can use the context directly.

### Impact

- ~27 files touched
- Most are mechanical signature changes in mergeop implementations
- Real work in: `mergeop/context.go` (new), `match.go`, `patch.go`, `diff.go`, `eval/expand_env.go`, `schema/schema.go`

### Relation to Existing Cycle Detection

- **Static `ValidateCycles`**: Runs at schema load time, uses SAT solver to detect impossible cycles (no escape hatches)
- **Runtime `ctx.expanding`**: Simple stack-based detection during expansion to prevent infinite loops

These are complementary - static validation ensures cycles are structurally sound, runtime detection handles expansion termination.
