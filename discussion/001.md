<!-- Comment 001 - 2025-12-22T18:56:52+01:00 -->

## Implementation Progress

### Completed on issue-009 branch:
- TagTree parsing for tags like `!array(int)`
- Definition instantiation (`InstantiateDef`) with parameter substitution
- Expr-lang AST patching for auto-calling parameterized defs (`.[array]` â†’ `array()`)
- Basic `Schema.Validate(doc)` that expands Accept and calls `tony.Match`

### Current Limitation:
`tony.Match` has no schema awareness. When it encounters:
- `.[defname]` strings - not resolved to definitions
- Unknown tags like `!string` (after param substitution) - not resolved to type constraints

The mergeop system only knows built-in ops (`!and`, `!or`, `!irtype`, etc.), not schema-defined types.

## Design Options for Schema-Aware Validation

### Option A: Schema-Aware Lookup (Minimal Change)
Extend `mergeop.Lookup` to fallback to schema definitions.

```go
func LookupWithSchema(name string, schema *schema.Schema) Symbol {
    if sym := Lookup(name); sym != nil { return sym }
    if def, ok := schema.Define[name]; ok {
        return &schemaDefSymbol{name, def, schema}
    }
    return nil
}
```

- Pros: Minimal changes, reuses mergeop machinery
- Cons: Schema threading problem, doesn't use context system

### Option B: Context-Scoped Definitions
Extend Context to hold compiled schema definitions as mergeop Symbols.

```go
type Context struct {
    ...
    Symbols map[string]mergeop.Symbol  // compiled definitions
}

func (s *Schema) Compile() error {
    for name, def := range s.Define {
        s.Context.Symbols[name] = compileDefToSymbol(name, def, s)
    }
}

func MatchWithContext(doc, match *ir.Node, ctx *Context) (bool, error)
```

- Pros: Clean separation, uses context as designed, scoped (no global pollution)
- Cons: Requires threading context through match calls

### Option C: Compiled MatchFunc (Self-Contained)
Schema compiles to a standalone match function closure.

```go
func (s *Schema) Matcher() func(doc, pattern *ir.Node) (bool, error) {
    return func(doc, pattern *ir.Node) (bool, error) {
        // Custom match logic resolving definitions from schema
    }
}
```

- Pros: Self-contained, no global state
- Cons: Duplicates mergeop machinery, doesn't compose with existing ops

## Open Questions for Option B

1. Context threading impact - where does context need to flow?
2. Can we have a non-context default for simple cases?
3. Where does tony-base schema fit - is it the "default context"?

