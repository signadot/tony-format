<!-- Comment 001 - 2025-12-21T17:28:37+01:00 -->

## Existing Code

**API layer** (`api/api.go`):
- `WatchMeta` struct defined with:
  - `EncodingOptions` (wire, brackets)
  - `From *int64` - start commit
  - `To *int64` - end commit (for bounded range)

**Server layer** (`server/server.go`):
- Routes MATCH and PATCH to handlers
- No WATCH handler yet

**Storage layer**:
- `GetCurrentCommit()` - returns latest commit
- `ReadStateAt(kpath, commit)` - read state at specific commit
- No commit notification/subscription mechanism yet

## WATCH Design Considerations

### 1. Request Format
```tony
!watch {
  meta: { from: 5 }     # start from commit 5 (or latest if omitted)
  body: { path: users } # path to watch
}
```

### 2. Response Stream
Options:
- **Full state + diffs**: Send full state at `from`, then diffs for subsequent commits
- **Diffs only**: Client already has state, just send patches
- **Events**: Higher-level (added/modified/deleted) like k8s watch

### 3. Storage Layer Needs
- `Subscribe(kpath, fromCommit) <-chan Event` or similar
- Notification when commits affect watched path
- Coordinate with tx system - notify after commit, not during

### 4. Transport (ties to #38)
- HTTP chunked encoding for simple case
- WebSocket/xap for bidirectional (client can close early)
- Must support read timeouts for controller robustness
- gRPC/HTTP2 ruled out (no per-read timeouts)

### 5. Coordination with Transactions
- Watch should see commits atomically (all patches in tx together)
- Watch should not block commits
- Backpressure: what if client is slow? Buffer? Drop? Error?

### 6. Memory Constraints
- Sending full diffs may require materializing (see #32 comment on !arraydiff)
- Streaming-safe: prefer !key arrays, simple field patches

## Open Questions
1. Initial state: full snapshot or assume client has it?
2. Reconnection: client provides last-seen commit, server resumes from there?
3. Path granularity: watch `users` vs `users[*]` vs `users.*.status`?
4. Filtering: watch only changes matching a pattern?

