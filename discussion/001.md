<!-- Comment 001 - 2025-12-26T14:29:38+01:00 -->

## Design Checkpoint (2024-12-26)

### Priority: A+B
- **A**: Clients query schema (validation/UI)
- **B**: Live schema changes with migration

### Wire Protocol

Return actual Tony schema document, not logd internal representation.

**Get:**
```
{schema: {get: true}}
→ {result: {schema: <tony schema doc>, schemaVersion: 3}}
```

**Set (baseline only):**
```
{schema: {set: <tony schema doc>}}
→ {result: {schemaVersion: 4}}
```

### Scope + Schema Model

**Two scope types:**
- **No schema override**: Uses baseline schema, always current, never invalidated
- **With schema override**: Fixed to declared schema, may become stale

**On baseline schema change:**
1. Re-index baseline (background, use #56 diff for affected paths)
2. Scopes without override: unaffected (see new schema automatically)
3. Scopes with override: invalidated → `{error: {code: "scope_schema_stale"}}`

**Why per-scope (not per-path) invalidation:**
- Simple: scope metadata says if at risk
- No partial compatibility analysis
- Easy to reason about and debug

### Implementation Sketch
1. Schema version counter in baseline
2. SchemaRequest/SchemaResult in session protocol  
3. Scope metadata: optional schema override + baseline_schema_version at creation
4. On scope op: if has override && baseline advanced → reject
5. Background re-index on baseline schema change

