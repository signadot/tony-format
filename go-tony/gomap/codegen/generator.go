package codegen

import (
	"bytes"
	"encoding"
	"fmt"
	"go/ast"
	"go/format"
	"reflect"
	"sort"
	"strings"

	"github.com/signadot/tony-format/go-tony/schema"
)

var (
	textMarshalerType   = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
	textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
)

// getIRNodeDepth returns the depth of the pointer if the type is a pointer to ir.Node.
// Returns 0 if it's not a pointer to ir.Node.
// e.g. *ir.Node -> 1, **ir.Node -> 2
func getIRNodeDepth(t reflect.Type) int {
	if t == nil {
		return 0
	}
	depth := 0
	current := t
	for current.Kind() == reflect.Ptr {
		depth++
		current = current.Elem()
	}

	// Check if the base type is ir.Node
	if current.Name() == "Node" && strings.HasSuffix(current.PkgPath(), "/ir") {
		return depth
	}
	return 0
}

// methodAcceptsOpts checks if a type's method accepts an opts parameter.
// For types in the current package being generated, always returns true since they will have opts.
// For external types, uses reflection to check if the method exists and accepts more than minInputs.
func methodAcceptsOpts(t reflect.Type, currentPkgPath, methodName string, minInputs int) bool {
	if t == nil {
		return false
	}
	// Unwrap pointers to get base type
	baseType := t
	for baseType.Kind() == reflect.Ptr {
		baseType = baseType.Elem()
	}
	// Types in the current package being generated will have opts
	if baseType.PkgPath() == currentPkgPath {
		return true
	}
	// For external types, use reflection to check
	pt := t
	if t.Kind() != reflect.Ptr {
		pt = reflect.PtrTo(t)
	}
	method, ok := pt.MethodByName(methodName)
	if !ok {
		return false
	}
	return method.Type.NumIn() > minInputs
}

// fromTonyIRAcceptsOpts checks if a type's FromTonyIR method accepts the opts parameter.
// Returns true if the method signature is FromTonyIR(*ir.Node, ...UnmapOption), false otherwise.
func fromTonyIRAcceptsOpts(t reflect.Type, currentPkgPath string) bool {
	// FromTonyIR has receiver + *ir.Node + ...opts = 3 inputs; without opts = 2
	return methodAcceptsOpts(t, currentPkgPath, "FromTonyIR", 2)
}

// fromTonyIROptsSuffix returns ", opts..." if the type's FromTonyIR accepts opts, "" otherwise.
func fromTonyIROptsSuffix(t reflect.Type, currentPkgPath string) string {
	if fromTonyIRAcceptsOpts(t, currentPkgPath) {
		return ", opts..."
	}
	return ""
}

// toTonyIRAcceptsOpts checks if a type's ToTonyIR method accepts the opts parameter.
// Returns true if the method signature is ToTonyIR(...MapOption), false otherwise.
func toTonyIRAcceptsOpts(t reflect.Type, currentPkgPath string) bool {
	// ToTonyIR has receiver + ...opts = 2 inputs; without opts = 1
	return methodAcceptsOpts(t, currentPkgPath, "ToTonyIR", 1)
}

// toTonyIROptsSuffix returns "opts..." if the type's ToTonyIR accepts opts, "" otherwise.
func toTonyIROptsSuffix(t reflect.Type, currentPkgPath string) string {
	if toTonyIRAcceptsOpts(t, currentPkgPath) {
		return "opts..."
	}
	return ""
}


// GenerateCode generates Go code for ToTony() and FromTony() methods for all structs.
// Returns formatted Go source code.
func GenerateCode(structs []*StructInfo, schemas map[string]*schema.Schema, config *CodegenConfig) (string, error) {
	var buf strings.Builder

	// Write header
	buf.WriteString("// Code generated by tony-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", config.Package.Name))
	buf.WriteString("import (\n")
	buf.WriteString(`	"bytes"` + "\n")
	buf.WriteString(`	"fmt"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/encode"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/gomap"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/ir"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/parse"` + "\n")

	// Collect external package imports from all structs
	externalImports := make(map[string]bool)
	for _, structInfo := range structs {
		if structInfo.StructSchema == nil {
			continue
		}

		// Helper to collect imports from a type
		var collectImports func(reflect.Type)
		collectImports = func(t reflect.Type) {
			if t == nil {
				return
			}
			// Handle pointers
			for t.Kind() == reflect.Ptr {
				t = t.Elem()
			}

			// Check for named types from other packages
			if t.PkgPath() != "" && t.PkgPath() != config.Package.Path {
				// We need the import path.
				// For now, we rely on the structInfo.Imports map which maps package name to path.
				// But t.PkgPath() IS the import path.
				externalImports[t.PkgPath()] = true
			}

			// Handle containers
			switch t.Kind() {
			case reflect.Slice, reflect.Array:
				collectImports(t.Elem())
			case reflect.Map:
				collectImports(t.Key())
				collectImports(t.Elem())
			case reflect.Struct:
				// For structs, we might need to look up their fields if we were doing deep traversal,
				// but here we only care about the types directly referenced in the generated code.
				// If t is a named struct from another package, we added it above.
			}
		}

		// Check the struct type itself (in case it's a named container type)
		if structInfo.Type != nil {
			collectImports(structInfo.Type)
		}

		// Check all fields for external types
		for _, field := range structInfo.Fields {
			// For types with TextMarshaler/TextUnmarshaler from same package, skip import
			// For external package types, we still need the import since we use new(pkg.Type)
			if (field.ImplementsTextMarshaler || field.ImplementsTextUnmarshaler) && field.TypePkgPath == "" {
				continue
			}
			if field.Type != nil {
				collectImports(field.Type)
			}
			// Also check explicit StructTypeName for cases where reflection might be incomplete
			if field.StructTypeName != "" && strings.Contains(field.StructTypeName, ".") {
				// Extract package name (e.g., "format" from "format.Format")
				parts := strings.Split(field.StructTypeName, ".")
				if len(parts) == 2 {
					pkgName := parts[0]
					// Look up the import path from the struct's Imports map
					if importPath, ok := structInfo.Imports[pkgName]; ok {
						externalImports[importPath] = true
					}
				}
			}
			// External types implementing TextUnmarshaler still need import for new(pkg.Type)
			if field.TypePkgPath != "" {
				externalImports[field.TypePkgPath] = true
			}
		}
	}

	// Add external imports in sorted order for consistency
	var importPaths []string
	for importPath := range externalImports {
		importPaths = append(importPaths, importPath)
	}
	sort.Strings(importPaths)
	for _, importPath := range importPaths {
		buf.WriteString(fmt.Sprintf("\t%q\n", importPath))
	}

	// Check if standard imports are needed
	needsStrconv := false
	needsUnsafe := false

	for _, structInfo := range structs {
		if structInfo.StructSchema == nil {
			continue
		}
		for _, field := range structInfo.Fields {
			if field.Type == nil {
				continue
			}
			// Check for map types that require special handling
			if field.Type.Kind() == reflect.Map {
				keyType := field.Type.Key()
				// map[uint32]T needs strconv for parsing keys
				if keyType.Kind() == reflect.Uint32 {
					needsStrconv = true
				}
				// map[*T]T needs unsafe for pointer keys
				if keyType.Kind() == reflect.Ptr {
					needsUnsafe = true
				}
			}
		}
	}

	// Add other standard imports if needed
	if needsStrconv {
		buf.WriteString(`	"strconv"` + "\n")
	}
	if needsUnsafe {
		buf.WriteString(`	"unsafe"` + "\n")
	}
	buf.WriteString(")\n\n")

	// Generate methods for each struct
	for _, structInfo := range structs {
		// Skip if struct doesn't have schema tag
		if structInfo.StructSchema == nil {
			continue
		}

		// Get schema for this struct
		schemaName := structInfo.StructSchema.SchemaName
		s, ok := schemas[schemaName]
		if !ok {
			return "", fmt.Errorf("schema %q not found for struct %q", schemaName, structInfo.Name)
		}

		// Check if methods already exist (skip code generation if they do)
		// Note: We can't check at codegen time since we're generating the code.
		// This check would need to be done at runtime or via AST analysis.
		// For now, we'll always generate the methods.

		// Generate ToTonyIR method
		toTonyIRCode, err := GenerateToTonyIRMethod(structInfo, s, config.Package.Path)
		if err != nil {
			return "", fmt.Errorf("failed to generate ToTonyIR() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(toTonyIRCode)
		buf.WriteString("\n\n")

		// Generate FromTonyIR method
		fromTonyIRCode, err := GenerateFromTonyIRMethod(structInfo, s, config.Package.Path)
		if err != nil {
			return "", fmt.Errorf("failed to generate FromTonyIR() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(fromTonyIRCode)
		buf.WriteString("\n\n")

		// Generate ToTony method
		toTonyCode, err := GenerateToTonyMethod(structInfo)
		if err != nil {
			return "", fmt.Errorf("failed to generate ToTony() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(toTonyCode)
		buf.WriteString("\n\n")

		// Generate FromTony method
		fromTonyCode, err := GenerateFromTonyMethod(structInfo)
		if err != nil {
			return "", fmt.Errorf("failed to generate FromTony() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(fromTonyCode)
		buf.WriteString("\n\n")
	}

	// Generate zero-value helper functions for optional fields
	zeroValueHelpers, err := GenerateZeroValueHelpers(structs)
	if err != nil {
		return "", fmt.Errorf("failed to generate zero-value helpers: %w", err)
	}
	if zeroValueHelpers != "" {
		buf.WriteString("// Zero-value check helpers\n")
		buf.WriteString(zeroValueHelpers)
		buf.WriteString("\n")
	}

	// Format the generated code
	codeStr := buf.String()
	formatted, err := format.Source([]byte(codeStr))
	if err != nil {
		// Return unformatted code if formatting fails (with error)
		// Include first 50 lines of code for debugging
		lines := strings.Split(codeStr, "\n")
		preview := strings.Join(lines[:min(50, len(lines))], "\n")
		// Show the problematic line if we can extract it from the error
		if len(lines) >= 191 {
			preview += fmt.Sprintf("\n\nLine 191: %s", lines[190])
		}
		// Show lines around the error (assuming error format is "line:col: message")
		errStr := err.Error()
		if strings.Contains(errStr, ":") {
			parts := strings.Split(errStr, ":")
			if len(parts) >= 2 {
				var lineNum int
				if _, parseErr := fmt.Sscanf(parts[0], "%d", &lineNum); parseErr == nil && lineNum > 0 && lineNum <= len(lines) {
					start := lineNum - 5
					if start < 0 {
						start = 0
					}
					end := lineNum + 5
					if end > len(lines) {
						end = len(lines)
					}
					preview += fmt.Sprintf("\n\nLines %d-%d:\n", start+1, end)
					for i := start; i < end; i++ {
						preview += fmt.Sprintf("%d: %s\n", i+1, lines[i])
					}
				}
			}
		}
		return codeStr, fmt.Errorf("failed to format generated code: %w\nFirst 50 lines:\n%s", err, preview)
	}

	return string(formatted), nil
}

// GenerateZeroValueHelpers generates helper functions for checking zero values of optional fields.
func GenerateZeroValueHelpers(structs []*StructInfo) (string, error) {
	var buf strings.Builder
	helpers := make(map[string]bool) // Track which helpers we've already generated

	for _, structInfo := range structs {
		if structInfo.StructSchema == nil {
			continue
		}

		for _, field := range structInfo.Fields {
			// Only generate helpers for optional non-pointer fields
			if !field.Optional {
				continue
			}
			if field.Type == nil {
				continue
			}
			if field.Type.Kind() == reflect.Ptr {
				continue // Pointer fields use nil checks, not zero-value checks
			}

			helperName := fmt.Sprintf("isZeroValue_%s_%s", structInfo.Name, field.Name)
			if helpers[helperName] {
				continue // Already generated
			}
			helpers[helperName] = true

			// Generate helper function based on field type
			// Use the actual field type (which may be a named type)
			typeStr := getTypeString(field.Type)
			
			switch field.Type.Kind() {
			case reflect.String:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return v == \"\"\n")
				buf.WriteString("}\n\n")

			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return v == 0\n")
				buf.WriteString("}\n\n")

			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return v == 0\n")
				buf.WriteString("}\n\n")

			case reflect.Float32, reflect.Float64:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return v == 0.0\n")
				buf.WriteString("}\n\n")

			case reflect.Bool:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return v == false\n")
				buf.WriteString("}\n\n")

			case reflect.Slice, reflect.Array:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return len(v) == 0\n")
				buf.WriteString("}\n\n")

			case reflect.Map:
				buf.WriteString(fmt.Sprintf("func %s(v %s) bool {\n", helperName, typeStr))
				buf.WriteString("	return len(v) == 0\n")
				buf.WriteString("}\n\n")

			default:
				// For other types, we might need a more sophisticated check
				// For now, skip generating helpers for complex types
				// They can be handled manually if needed
			}
		}
	}

	return buf.String(), nil
}

// getTypeString returns a string representation of a reflect.Type suitable for use in generated code.
func getTypeString(t reflect.Type) string {
	if t == nil {
		return "interface{}"
	}

	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Int:
		return "int"
	case reflect.Int8:
		return "int8"
	case reflect.Int16:
		return "int16"
	case reflect.Int32:
		return "int32"
	case reflect.Int64:
		return "int64"
	case reflect.Uint:
		return "uint"
	case reflect.Uint8:
		return "uint8"
	case reflect.Uint16:
		return "uint16"
	case reflect.Uint32:
		return "uint32"
	case reflect.Uint64:
		return "uint64"
	case reflect.Float32:
		return "float32"
	case reflect.Float64:
		return "float64"
	case reflect.Bool:
		return "bool"
	case reflect.Slice:
		return fmt.Sprintf("[]%s", getTypeString(t.Elem()))
	case reflect.Array:
		return fmt.Sprintf("[%d]%s", t.Len(), getTypeString(t.Elem()))
	case reflect.Map:
		return fmt.Sprintf("map[%s]%s", getTypeString(t.Key()), getTypeString(t.Elem()))
	case reflect.Ptr:
		return fmt.Sprintf("*%s", getTypeString(t.Elem()))
	default:
		// For named types, use the type name
		if t.Name() != "" {
			return t.Name()
		}
		return t.String()
	}
}

// GenerateToTonyIRMethod generates the ToTonyIR method for a struct.
func GenerateToTonyIRMethod(s *StructInfo, sSchema *schema.Schema, currentPkgPath string) (string, error) {
	var buf bytes.Buffer

	// Method signature
	buf.WriteString(fmt.Sprintf("// ToTonyIR converts %s to a Tony IR node.\n", s.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {\n", s.Name))
	buf.WriteString("	if s == nil {\n")
	buf.WriteString("		return ir.Null(), nil\n")
	buf.WriteString("	}\n")

	// Check for TextMarshaler implementation on the type itself
	if s.ImplementsTextMarshaler {
		buf.WriteString("	// Use TextMarshaler implementation\n")
		buf.WriteString("	txt, err := s.MarshalText()\n")
		buf.WriteString("	if err != nil {\n")
		buf.WriteString(fmt.Sprintf("		return nil, fmt.Errorf(\"failed to marshal %s: %%w\", err)\n", s.Name))
		buf.WriteString("	}\n")
		if s.StructSchema.NoTag {
			buf.WriteString("	return ir.FromString(string(txt)), nil\n")
		} else {
			buf.WriteString(fmt.Sprintf("	return ir.FromString(string(txt)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
		}
		buf.WriteString("}\n\n")
		return buf.String(), nil
	}

	// Handle basic types (non-structs)
	if s.Type != nil && s.Type.Kind() != reflect.Struct {
		// Basic type conversion
		tag := ""
		if !s.StructSchema.NoTag {
			tag = fmt.Sprintf(".WithTag(%q)", "!"+s.StructSchema.SchemaName)
		}
		switch s.Type.Kind() {
		case reflect.String:
			buf.WriteString(fmt.Sprintf("	return ir.FromString(string(*s))%s, nil\n", tag))
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			buf.WriteString(fmt.Sprintf("	return ir.FromInt(int64(*s))%s, nil\n", tag))
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			// ir.FromInt takes int64, so we might lose precision for uint64 > max int64
			// But for now let's cast to int64
			buf.WriteString(fmt.Sprintf("	return ir.FromInt(int64(*s))%s, nil\n", tag))
		case reflect.Float32, reflect.Float64:
			buf.WriteString(fmt.Sprintf("	return ir.FromFloat(float64(*s))%s, nil\n", tag))
		case reflect.Bool:
			buf.WriteString(fmt.Sprintf("	return ir.FromBool(bool(*s))%s, nil\n", tag))

		// Handle container types (Slice, Array, Map)
		case reflect.Slice, reflect.Array:
			// Reuse field generation logic but for the top-level type
			// We create a fake field info to reuse generateFieldToIR logic,
			// but we need to adapt it because generateFieldToIR assumes it's accessing a field of a struct (s.Field).
			// Here we are accessing *s directly.

			// Implement slice handling directly here for better control over the generated code.
			elemType := s.Type.Elem()
			buf.WriteString("	if len(*s) > 0 {\n")
			buf.WriteString(fmt.Sprintf("		slice := make([]*ir.Node, len(*s))\n"))
			buf.WriteString("		for i, v := range *s {\n")

			if depth := getIRNodeDepth(elemType); depth > 0 {
				// Slice of *ir.Node (or deeper)
				derefs := ""
				for j := 0; j < depth-1; j++ {
					derefs += "*"
				}
				buf.WriteString(fmt.Sprintf("			slice[i] = %sv\n", derefs))
			} else if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) || (elemType.Name() != "" && elemType.Kind() != reflect.String && !isPrimitiveKind(elemType.Kind())) || elemType.Kind() == reflect.Slice || elemType.Kind() == reflect.Map || elemType.Kind() == reflect.Array {
				// Slice of structs, pointers to structs, or other complex types (named types, nested containers)
				if elemType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("			node, err := v.ToTonyIR(%s)\n", toTonyIROptsSuffix(elemType.Elem(), currentPkgPath)))
				} else {
					// v is a value, we need to call ToTonyIR on pointer
					buf.WriteString(fmt.Sprintf("			node, err := (&v).ToTonyIR(%s)\n", toTonyIROptsSuffix(elemType, currentPkgPath)))
				}
				buf.WriteString("			if err != nil {\n")
				buf.WriteString("				return nil, fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
				buf.WriteString("			}\n")
				buf.WriteString("			slice[i] = node\n")
			} else {
				// Slice of primitives
				elemCode, err := generatePrimitiveToIR("v", elemType)
				if err != nil {
					return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
				}
				buf.WriteString(fmt.Sprintf("			slice[i] = %s\n", elemCode))
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		return ir.FromSlice(slice)%s, nil\n", tag))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	return ir.FromSlice(nil)%s, nil\n", tag))

		case reflect.Map:
			keyType := s.Type.Key()
			valueType := s.Type.Elem()

			if keyType.Kind() == reflect.Uint32 {
				// Sparse array (map[uint32]T)
				buf.WriteString("	if len(*s) > 0 {\n")
				buf.WriteString("		intKeysMap := make(map[uint32]*ir.Node)\n")
				buf.WriteString("		for k, v := range *s {\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			node, err := v.ToTonyIR(%s)\n", toTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					} else {
						buf.WriteString(fmt.Sprintf("			node, err := (&v).ToTonyIR(%s)\n", toTonyIROptsSuffix(valueType, currentPkgPath)))
					}
					buf.WriteString("			if err != nil {\n")
					buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			intKeysMap[k] = node\n")
				} else {
					valueCode, err := generatePrimitiveToIR("v", valueType)
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			intKeysMap[k] = %s\n", valueCode))
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		return ir.FromIntKeysMap(intKeysMap)%s, nil\n", tag))
				buf.WriteString("	}\n")
				buf.WriteString(fmt.Sprintf("	return ir.FromIntKeysMap(nil)%s, nil\n", tag))

			} else if keyType.Kind() == reflect.String {
				// Regular map (map[string]T)
				buf.WriteString("	if len(*s) > 0 {\n")
				buf.WriteString("		mapNodes := make(map[string]*ir.Node)\n")
				buf.WriteString("		for k, v := range *s {\n")

				if depth := getIRNodeDepth(valueType); depth > 0 {
					// Map value is *ir.Node (or deeper)
					derefs := ""
					for j := 0; j < depth-1; j++ {
						derefs += "*"
					}
					buf.WriteString(fmt.Sprintf("			mapNodes[k] = %sv\n", derefs))
				} else if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			node, err := v.ToTonyIR(%s)\n", toTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					} else {
						buf.WriteString(fmt.Sprintf("			node, err := (&v).ToTonyIR(%s)\n", toTonyIROptsSuffix(valueType, currentPkgPath)))
					}
					buf.WriteString("			if err != nil {\n")
					buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			mapNodes[k] = node\n")
				} else {
					valueCode, err := generatePrimitiveToIR("v", valueType)
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			mapNodes[k] = %s\n", valueCode))
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		return ir.FromMap(mapNodes)%s, nil\n", tag))
				buf.WriteString("	}\n")
				buf.WriteString(fmt.Sprintf("	return ir.FromMap(nil)%s, nil\n", tag))

			} else if keyType.Kind() == reflect.Interface {
				// Map with interface{} keys
				buf.WriteString("	if len(*s) > 0 {\n")
				buf.WriteString("		mapNodes := make(map[string]*ir.Node)\n")
				buf.WriteString("		for k, v := range *s {\n")
				buf.WriteString("			kStr := fmt.Sprintf(\"%v\", k)\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			node, err := v.ToTonyIR(%s)\n", toTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					} else {
						buf.WriteString(fmt.Sprintf("			node, err := (&v).ToTonyIR(%s)\n", toTonyIROptsSuffix(valueType, currentPkgPath)))
					}
					buf.WriteString("			if err != nil {\n")
					buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %v: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			mapNodes[kStr] = node\n")
				} else {
					valueCode, err := generatePrimitiveToIR("v", valueType)
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			mapNodes[kStr] = %s\n", valueCode))
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		return ir.FromMap(mapNodes)%s, nil\n", tag))
				buf.WriteString("	}\n")
				buf.WriteString(fmt.Sprintf("	return ir.FromMap(nil)%s, nil\n", tag))
			} else {
				return "", fmt.Errorf("unsupported map key type for top-level map: %v", keyType.Kind())
			}

		default:
			return "", fmt.Errorf("unsupported basic type for schema generation: %v", s.Type.Kind())
		}
		// buf.WriteString("}\n\n") // Removed because we return directly in cases
		return buf.String(), nil
	}

	// Determine if we need variables
	needsVars := false
	for _, field := range s.Fields {
		if field.Omit {
			continue
		}
		// Complex fields might need error handling or temporary variables
		if field.Type.Kind() == reflect.Struct ||
			(field.Type.Kind() == reflect.Ptr && field.Type.Elem().Kind() == reflect.Struct) ||
			(field.Type.Kind() == reflect.Slice && field.Type.Elem().Kind() == reflect.Struct) ||
			(field.Type.Kind() == reflect.Slice && field.Type.Elem().Kind() == reflect.Ptr && field.Type.Elem().Elem().Kind() == reflect.Struct) ||
			(field.Type.Kind() == reflect.Map && field.Type.Elem().Kind() == reflect.Struct) ||
			field.Type.Kind() == reflect.Interface {
			needsVars = true
			break
		}
		// TextMarshaler fields need error handling
		if field.ImplementsTextMarshaler {
			needsVars = true
			break
		}
	}

	if needsVars {
		buf.WriteString("	var node *ir.Node\n")
		buf.WriteString("	var err error\n")
		buf.WriteString("	_ = node // suppress unused variable error\n")
		buf.WriteString("	_ = err  // suppress unused variable error\n\n")
	}

	// Create IR object map
	buf.WriteString("	// Create IR object map\n")
	buf.WriteString("	irMap := make(map[string]*ir.Node)\n\n")

	// Generate code for each field
	for i, field := range s.Fields {
		if field.Omit {
			continue
		}

		// Get schema field name
		schemaFieldName := field.SchemaFieldName
		if schemaFieldName == "" {
			schemaFieldName = field.Name
		}

		// Handle optional fields (skip zero values)
		if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
			buf.WriteString(fmt.Sprintf("	// Field: %s (optional)\n", field.Name))
			if field.Type != nil && field.Type.Kind() == reflect.Ptr {
				buf.WriteString(fmt.Sprintf("	if s.%s != nil {\n", field.Name))
			} else {
				// Non-pointer optional field - check if zero value
				buf.WriteString(fmt.Sprintf("	if !isZeroValue_%s_%s(s.%s) {\n", s.Name, field.Name, field.Name))
			}
		} else {
			buf.WriteString(fmt.Sprintf("	// Field: %s\n", field.Name))
		}

		// Generate code to convert field to IR node
		// Pass true for alreadyInNilCheck if we've already wrapped this field in a nil check
		alreadyInNilCheck := field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr)
		fieldCode, err := generateFieldToIR(s, field, schemaFieldName, i != 0, needsVars, alreadyInNilCheck, currentPkgPath)
		if err != nil {
			return "", fmt.Errorf("failed to generate field conversion for %q: %w", field.Name, err)
		}
		buf.WriteString(fieldCode)

		if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
			buf.WriteString("	}\n")
		}
		buf.WriteString("\n")
	}

	// Create IR node (with schema tag unless notag is set)
	if s.StructSchema.NoTag {
		buf.WriteString("	return ir.FromMap(irMap), nil\n")
	} else {
		buf.WriteString(fmt.Sprintf("	return ir.FromMap(irMap).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
	}
	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateFieldToIR generates code to convert a struct field to an IR node.
// alreadyInNilCheck indicates if the field is already wrapped in a nil check (for optional pointer fields).
func generateFieldToIR(structInfo *StructInfo, field *FieldInfo, schemaFieldName string, redef bool, varsDeclared bool, alreadyInNilCheck bool, currentPkgPath string) (string, error) {
	var buf strings.Builder

	// Use := if variables aren't declared at function level, otherwise use =
	// This avoids shadowing when variables are already declared
	assign := ":="
	if varsDeclared {
		assign = "="
	}

	if field.Type == nil {
		return "", fmt.Errorf("field %q has no type information", field.Name)
	}

	// Special handling for *ir.Node (and deeper pointers)
	if depth := getIRNodeDepth(field.Type); depth > 0 {
		// Dereference if depth > 1 (we want *ir.Node)
		derefs := ""
		for i := 0; i < depth-1; i++ {
			derefs += "*"
		}

		// Only add nil check if not already in one (for optional pointer fields)
		if !alreadyInNilCheck {
			buf.WriteString(fmt.Sprintf("	if s.%s == nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.Null()\n", schemaFieldName))
			buf.WriteString("	} else {\n")
			buf.WriteString(fmt.Sprintf("		irMap[%q] = %ss.%s\n", schemaFieldName, derefs, field.Name))
			buf.WriteString("	}\n")
		} else {
			// Already in nil check - just assign directly
			buf.WriteString(fmt.Sprintf("		irMap[%q] = %ss.%s\n", schemaFieldName, derefs, field.Name))
		}
		return buf.String(), nil
	}

	// Check for encoding.TextMarshaler using the flag set during type resolution
	// We use the flag instead of runtime reflection because custom types like `type A int`
	// don't preserve methods in reflect.Type
	if field.ImplementsTextMarshaler {
		// For pointer fields, we need to handle nil before calling MarshalText
		// If alreadyInNilCheck is true, we're already inside a nil check (optional field)
		if field.Type.Kind() == reflect.Ptr && !alreadyInNilCheck {
			// Required pointer field - add nil check
			buf.WriteString(fmt.Sprintf("	if s.%s == nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.Null()\n", schemaFieldName))
			buf.WriteString("	} else {\n")
			buf.WriteString(fmt.Sprintf("		if txt, err := s.%s.MarshalText(); err != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			return nil, fmt.Errorf(\"failed to marshal field %%q: %%w\", %q, err)\n", field.Name))
			buf.WriteString("		} else {\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromString(string(txt))\n", schemaFieldName))
			buf.WriteString("		}\n")
			buf.WriteString("	}\n")
		} else {
			// Value type or already in nil check - call directly
			buf.WriteString(fmt.Sprintf("	if txt, err := s.%s.MarshalText(); err != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("		return nil, fmt.Errorf(\"failed to marshal field %%q: %%w\", %q, err)\n", field.Name))
			buf.WriteString("	} else {\n")
			buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromString(string(txt))\n", schemaFieldName))
			buf.WriteString("	}\n")
		}
		return buf.String(), nil
	}

	// Handle different field types
	switch field.Type.Kind() {
	case reflect.String:
		buf.WriteString(fmt.Sprintf("\tirMap[%q] = ir.FromString(s.%s)\n", schemaFieldName, field.Name))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString(fmt.Sprintf("\tirMap[%q] = ir.FromInt(int64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		// For unsigned types, we need to handle them carefully
		buf.WriteString(fmt.Sprintf("\tirMap[%q] = ir.FromInt(int64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("\tirMap[%q] = ir.FromFloat(float64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Bool:
		if field.Omitzero {
			buf.WriteString(fmt.Sprintf("\tif s.%s {\n", field.Name))
			buf.WriteString(fmt.Sprintf("\t\tirMap[%q] = ir.FromBool(s.%s)\n", schemaFieldName, field.Name))
			buf.WriteString("\t}\n")
		} else {
			buf.WriteString(fmt.Sprintf("\tirMap[%q] = ir.FromBool(s.%s)\n", schemaFieldName, field.Name))
		}

	case reflect.Ptr:
		// Pointer type - dereference and recurse
		elemType := field.Type.Elem()
		if elemType.Kind() == reflect.Struct {
			// Nested struct - call ToTony() method
			// Only add nil check if we're not already inside one
			if !alreadyInNilCheck {
				buf.WriteString(fmt.Sprintf("	if s.%s != nil {\n", field.Name))
			}
			buf.WriteString(fmt.Sprintf("		node, err %s s.%s.ToTonyIR(%s)\n", assign, field.Name, toTonyIROptsSuffix(elemType, currentPkgPath)))
			buf.WriteString("		if err != nil {\n")
			buf.WriteString("			return nil, err\n")
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		irMap[%q] = node\n", schemaFieldName))
			if !alreadyInNilCheck {
				buf.WriteString("	}\n")
			}
		} else {
			// Pointer to primitive - handle based on element type
			// Only add nil check if we're not already inside one
			if !alreadyInNilCheck {
				buf.WriteString(fmt.Sprintf("	if s.%s != nil {\n", field.Name))
			}
			fieldCode, err := generateFieldToIR(structInfo, &FieldInfo{
				Name: field.Name,
				Type: elemType,
			}, schemaFieldName, false, varsDeclared, alreadyInNilCheck, currentPkgPath)
			if err != nil {
				return "", err
			}
			buf.WriteString(strings.Replace(fieldCode, fmt.Sprintf("s.%s", field.Name), fmt.Sprintf("*s.%s", field.Name), -1))
			if !alreadyInNilCheck {
				buf.WriteString("	}\n")
			}
		}

	case reflect.Slice, reflect.Array:
		// Slice/Array type
		elemType := field.Type.Elem()
		buf.WriteString(fmt.Sprintf("	if len(s.%s) > 0 {\n", field.Name))
		buf.WriteString(fmt.Sprintf("		slice := make([]*ir.Node, len(s.%s))\n", field.Name))
		buf.WriteString(fmt.Sprintf("		for i, v := range s.%s {\n", field.Name))
		if depth := getIRNodeDepth(elemType); depth > 0 {
			// Slice of *ir.Node (or deeper) - use directly (with dereference if needed)
			derefs := ""
			for j := 0; j < depth-1; j++ {
				derefs += "*"
			}
			buf.WriteString(fmt.Sprintf("			slice[i] = %sv\n", derefs))
		} else if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) {
			// Slice of structs or pointers to structs - call ToTony()
			targetType := elemType
			if elemType.Kind() == reflect.Ptr {
				targetType = elemType.Elem()
			}
			buf.WriteString(fmt.Sprintf("			node, err %s v.ToTonyIR(%s)\n", assign, toTonyIROptsSuffix(targetType, currentPkgPath)))
			buf.WriteString("			if err != nil {\n")
			buf.WriteString("				return nil, fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
			buf.WriteString("			}\n")
			buf.WriteString("			slice[i] = node\n")
		} else {
			// Slice of primitives - generate element conversion
			elemCode, err := generatePrimitiveToIR("v", elemType)
			if err != nil {
				return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
			}
			buf.WriteString(fmt.Sprintf("			slice[i] = %s\n", elemCode))
		}
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromSlice(slice)\n", schemaFieldName))
		buf.WriteString("	}\n")

	case reflect.Map:
		// Map type
		keyType := field.Type.Key()
		valueType := field.Type.Elem()

		if keyType.Kind() == reflect.Uint32 {
			// Sparse array (map[uint32]T)
			buf.WriteString(fmt.Sprintf("	if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("		intKeysMap := make(map[uint32]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("		for k, v := range s.%s {\n", field.Name))
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				targetType := valueType
				if valueType.Kind() == reflect.Ptr {
					targetType = valueType.Elem()
				}
				buf.WriteString(fmt.Sprintf("			node, err %s v.ToTonyIR(%s)\n", assign, toTonyIROptsSuffix(targetType, currentPkgPath)))
				buf.WriteString("			if err != nil {\n")
				buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
				buf.WriteString("			}\n")
				buf.WriteString("			intKeysMap[k] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("			intKeysMap[k] = %s\n", valueCode))
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromIntKeysMap(intKeysMap)\n", schemaFieldName))
			buf.WriteString("	}\n")
		} else if keyType.Kind() == reflect.String {
			// Regular map (map[string]T)
			buf.WriteString(fmt.Sprintf("	if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("	mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("	for k, v := range s.%s {\n", field.Name))
			if depth := getIRNodeDepth(valueType); depth > 0 {
				// Map value is *ir.Node (or deeper)
				derefs := ""
				for j := 0; j < depth-1; j++ {
					derefs += "*"
				}
				buf.WriteString(fmt.Sprintf("		mapNodes[k] = %sv\n", derefs))
			} else if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				targetType := valueType
				if valueType.Kind() == reflect.Ptr {
					targetType = valueType.Elem()
				}
				buf.WriteString(fmt.Sprintf("		node, err %s v.ToTonyIR(%s)\n", assign, toTonyIROptsSuffix(targetType, currentPkgPath)))
				buf.WriteString("		if err != nil {\n")
				buf.WriteString("			return nil, fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
				buf.WriteString("		}\n")
				buf.WriteString("		mapNodes[k] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("		mapNodes[k] = %s\n", valueCode))
			}
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("	}\n")
		} else if keyType.Kind() == reflect.Interface {
			// Map with interface{} (any) keys - convert keys to strings
			buf.WriteString(fmt.Sprintf("	if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("	mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("	for k, v := range s.%s {\n", field.Name))
			buf.WriteString("		// Convert interface{} key to string\n")
			buf.WriteString("		kStr := fmt.Sprintf(\"%v\", k)\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				targetType := valueType
				if valueType.Kind() == reflect.Ptr {
					targetType = valueType.Elem()
				}
				buf.WriteString(fmt.Sprintf("		node, err %s v.ToTonyIR(%s)\n", assign, toTonyIROptsSuffix(targetType, currentPkgPath)))
				buf.WriteString("		if err != nil {\n")
				buf.WriteString("			return nil, fmt.Errorf(\"failed to convert map value at key %v: %w\", k, err)\n")
				buf.WriteString("		}\n")
				buf.WriteString("		mapNodes[kStr] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("		mapNodes[kStr] = %s\n", valueCode))
			}
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("	}\n")
		} else if keyType.Kind() == reflect.Ptr {
			// Map with pointer keys - convert pointers to strings
			buf.WriteString(fmt.Sprintf("	if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("	mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("	for k, v := range s.%s {\n", field.Name))
			buf.WriteString("		// Convert pointer key to string representation\n")
			buf.WriteString("		kStr := fmt.Sprintf(\"%p\", k)\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				targetType := valueType
				if valueType.Kind() == reflect.Ptr {
					targetType = valueType.Elem()
				}
				buf.WriteString(fmt.Sprintf("		node, err %s v.ToTonyIR(%s)\n", assign, toTonyIROptsSuffix(targetType, currentPkgPath)))
				buf.WriteString("		if err != nil {\n")
				buf.WriteString("			return nil, fmt.Errorf(\"failed to convert map value at key %p: %w\", k, err)\n")
				buf.WriteString("		}\n")
				buf.WriteString("		mapNodes[kStr] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("		mapNodes[kStr] = %s\n", valueCode))
			}
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("	}\n")
		} else {
			return "", fmt.Errorf("unsupported map key type: %v (only string, uint32, interface{}, and pointer types are supported)", keyType.Kind())
		}

	case reflect.Interface:
		// Interface{} type - use reflection-based conversion
		// For codegen, we'll use a helper that calls ToIR recursively
		buf.WriteString(fmt.Sprintf("	if s.%s != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("	// Interface{} conversion requires runtime reflection\n"))
		buf.WriteString(fmt.Sprintf("	node, err %s toIRInterface(s.%s)\n", assign, field.Name))
		buf.WriteString("	if err != nil {\n")
		buf.WriteString(fmt.Sprintf("		return nil, fmt.Errorf(\"failed to convert field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("	}\n")
		buf.WriteString(fmt.Sprintf("	irMap[%q] = node\n", schemaFieldName))
		buf.WriteString("	}\n")

	case reflect.Struct:
		// Nested struct - call ToTony() method
		buf.WriteString(fmt.Sprintf("	node, err %s s.%s.ToTonyIR(%s)\n", assign, field.Name, toTonyIROptsSuffix(field.Type, currentPkgPath)))
		buf.WriteString("	if err != nil {\n")
		buf.WriteString(fmt.Sprintf("		return nil, fmt.Errorf(\"failed to convert field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("	}\n")
		buf.WriteString(fmt.Sprintf("	irMap[%q] = node\n", schemaFieldName))

	default:
		return "", fmt.Errorf("unsupported field type: %v", field.Type.Kind())
	}

	return buf.String(), nil
}

// generatePrimitiveToIR generates code to convert a primitive value to an IR node.
// Returns the code expression (e.g., "ir.FromString(v)").
func generatePrimitiveToIR(varName string, typ reflect.Type) (string, error) {
	switch typ.Kind() {
	case reflect.String:
		return fmt.Sprintf("ir.FromString(%s)", varName), nil
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return fmt.Sprintf("ir.FromInt(int64(%s))", varName), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("ir.FromInt(int64(%s))", varName), nil
	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("ir.FromFloat64(float64(%s))", varName), nil
	case reflect.Bool:
		return fmt.Sprintf("ir.FromBool(%s)", varName), nil
	default:
		return "", fmt.Errorf("unsupported primitive type: %v", typ.Kind())
	}
}

// GenerateFromTonyIRMethod generates the FromTonyIR method for a struct.
func GenerateFromTonyIRMethod(s *StructInfo, sSchema *schema.Schema, currentPkgPath string) (string, error) {
	var buf bytes.Buffer

	// Method signature
	buf.WriteString(fmt.Sprintf("// FromTonyIR populates %s from a Tony IR node.\n", s.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {\n", s.Name))
	buf.WriteString("	if node == nil {\n")
	buf.WriteString("		return nil\n")
	buf.WriteString("	}\n\n")

	// Unwrap CommentType nodes
	buf.WriteString("	// Unwrap CommentType nodes to get the actual data node\n")
	buf.WriteString("	if node.Type == ir.CommentType {\n")

	// Extract Head Comments if configured
	if s.StructSchema != nil && s.StructSchema.CommentFieldName != "" {
		buf.WriteString(fmt.Sprintf("		s.%s = node.Lines\n", s.StructSchema.CommentFieldName))
	}

	buf.WriteString("		if len(node.Values) > 0 {\n")
	buf.WriteString("			node = node.Values[0]\n")
	buf.WriteString("		} else {\n")
	buf.WriteString("			return nil\n")
	buf.WriteString("		}\n")
	buf.WriteString("	}\n\n")

	// Extract Line Comments if configured
	if s.StructSchema != nil && s.StructSchema.LineCommentFieldName != "" {
		buf.WriteString("	if node.Comment != nil {\n")
		buf.WriteString(fmt.Sprintf("		s.%s = node.Comment.Lines\n", s.StructSchema.LineCommentFieldName))
		buf.WriteString("	}\n\n")
	}

	// Check for TextUnmarshaler implementation on the type itself
	if s.ImplementsTextUnmarshaler {
		buf.WriteString("	// Use TextUnmarshaler implementation\n")
		buf.WriteString("	if node.Type != ir.StringType {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected string for %s, got %%v\", node.Type)\n", s.Name))
		buf.WriteString("	}\n")
		buf.WriteString("	if err := s.UnmarshalText([]byte(node.String)); err != nil {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"failed to unmarshal %s: %%w\", err)\n", s.Name))
		buf.WriteString("	}\n")
		buf.WriteString("	return nil\n")
		buf.WriteString("}\n\n")
		return buf.String(), nil
	}

	// Handle basic types (non-structs)
	if s.Type != nil && s.Type.Kind() != reflect.Struct {
		// Basic type conversion
		switch s.Type.Kind() {
		case reflect.String:
			buf.WriteString("	if node.Type != ir.StringType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected string for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.String)\n", s.Name))
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			buf.WriteString("	if node.Type != ir.IntType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected int for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Int)\n", s.Name))
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			buf.WriteString("	if node.Type != ir.IntType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected int for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Int)\n", s.Name))
		case reflect.Float32, reflect.Float64:
			buf.WriteString("	if node.Type != ir.FloatType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected float for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Float)\n", s.Name))
		case reflect.Bool:
			buf.WriteString("	if node.Type != ir.BoolType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected bool for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Bool)\n", s.Name))

		// Handle container types (Slice, Array, Map)
		case reflect.Slice, reflect.Array:
			elemType := s.Type.Elem()
			buf.WriteString("	if node.Type == ir.ArrayType {\n")

			// Use qualified type name for the slice element type
			structName := getQualifiedTypeName(elemType, currentPkgPath)

			buf.WriteString(fmt.Sprintf("		slice := make([]%s, len(node.Values))\n", structName))
			buf.WriteString("		for i, v := range node.Values {\n")

			if depth := getIRNodeDepth(elemType); depth > 0 {
				// Slice of *ir.Node (or deeper)
				if depth == 1 {
					buf.WriteString("			slice[i] = v\n")
				} else {
					// Chain of pointers
					buf.WriteString("			v0 := v\n")
					for j := 1; j < depth; j++ {
						buf.WriteString(fmt.Sprintf("			v%d := &v%d\n", j, j-1))
					}
					buf.WriteString(fmt.Sprintf("			slice[i] = v%d\n", depth-1))
				}
			} else if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) || (elemType.Name() != "" && elemType.Kind() != reflect.String && !isPrimitiveKind(elemType.Kind())) || elemType.Kind() == reflect.Slice || elemType.Kind() == reflect.Map || elemType.Kind() == reflect.Array {
				// Slice of structs, pointers to structs, or other complex types
				if elemType.Kind() == reflect.Ptr {
					// Element is already a pointer, allocate new instance
					elemStructName := getQualifiedTypeName(elemType.Elem(), currentPkgPath)
					buf.WriteString(fmt.Sprintf("			elem := new(%s)\n", elemStructName))
					buf.WriteString(fmt.Sprintf("			if err := elem.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(elemType.Elem(), currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			slice[i] = elem\n")
				} else {
					// Element is a struct value
					buf.WriteString(fmt.Sprintf("			elem := %s{}\n", structName))
					buf.WriteString(fmt.Sprintf("			if err := elem.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(elemType, currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			slice[i] = elem\n")
				}
			} else {
				// Slice of primitives
				buf.WriteString("			ctx := fmt.Sprintf(\"slice element %d\", i)\n")
				elemCode, err := generatePrimitiveFromIR("v", elemType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
				}
				buf.WriteString(fmt.Sprintf("			var elem %s\n", getQualifiedTypeName(elemType, currentPkgPath)))
				buf.WriteString(fmt.Sprintf("			%s\n", elemCode))
				buf.WriteString("			slice[i] = elem\n")
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		*s = %s(slice)\n", s.Name))
			buf.WriteString("	}\n")

		case reflect.Map:
			keyType := s.Type.Key()
			valueType := s.Type.Elem()

			if keyType.Kind() == reflect.Uint32 {
				// Sparse array (map[uint32]T)
				buf.WriteString("	if node.Type == ir.ObjectType && node.Tag == \"!sparsearray\" {\n")
				structName := getQualifiedTypeName(valueType, currentPkgPath)
				buf.WriteString(fmt.Sprintf("		m := make(map[uint32]%s)\n", structName))
				buf.WriteString("		irMap := ir.ToMap(node)\n")
				buf.WriteString("		for kStr, v := range irMap {\n")
				buf.WriteString("			k, err := strconv.ParseUint(kStr, 10, 32)\n")
				buf.WriteString("			if err != nil {\n")
				buf.WriteString("				return fmt.Errorf(\"invalid sparse array key %q: %w\", kStr, err)\n")
				buf.WriteString("			}\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			val := new(%s)\n", getQualifiedTypeName(valueType.Elem(), currentPkgPath)))
						buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[uint32(k)] = val\n")
					} else {
						buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
						buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[uint32(k)] = val\n")
					}
				} else {
					buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %d\", k)\n")
					valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
					buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
					buf.WriteString("			m[uint32(k)] = val\n")
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*s = %s(m)\n", s.Name))
				buf.WriteString("	}\n")

			} else if keyType.Kind() == reflect.String {
				// Regular map (map[string]T)
				buf.WriteString("	if node.Type == ir.ObjectType {\n")
				structName := getQualifiedTypeName(valueType, currentPkgPath)
				if depth := getIRNodeDepth(valueType); depth > 0 {
					structName = "*ir.Node"
				}
				buf.WriteString(fmt.Sprintf("		m := make(map[string]%s)\n", structName))
				buf.WriteString("		irMap := ir.ToMap(node)\n")
				buf.WriteString("		for k, v := range irMap {\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			val := new(%s)\n", getQualifiedTypeName(valueType.Elem(), currentPkgPath)))
						buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					} else {
						buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
						buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					}
				} else if depth := getIRNodeDepth(valueType); depth > 0 {
					if depth == 1 {
						buf.WriteString("			m[k] = v\n")
					} else {
						buf.WriteString("			v0 := v\n")
						for j := 1; j < depth; j++ {
							buf.WriteString(fmt.Sprintf("			v%d := &v%d\n", j, j-1))
						}
						buf.WriteString(fmt.Sprintf("			m[k] = v%d\n", depth-1))
					}
				} else {
					buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %q\", k)\n")
					valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
					buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
					buf.WriteString("			m[k] = val\n")
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*s = %s(m)\n", s.Name))
				buf.WriteString("	}\n")

			} else if keyType.Kind() == reflect.Interface {
				// Map with interface{} keys
				buf.WriteString("	if node.Type == ir.ObjectType {\n")
				structName := getQualifiedTypeName(valueType, currentPkgPath)
				buf.WriteString(fmt.Sprintf("		m := make(map[interface{}]%s)\n", structName))
				buf.WriteString("		irMap := ir.ToMap(node)\n")
				buf.WriteString("		for kStr, v := range irMap {\n")
				buf.WriteString("			var k interface{} = kStr\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			val := new(%s)\n", getQualifiedTypeName(valueType.Elem(), currentPkgPath)))
						buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %v: %%w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					} else {
						buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
						buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %v: %%w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					}
				} else {
					buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %v\", k)\n")
					valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
					buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
					buf.WriteString("			m[k] = val\n")
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*s = %s(m)\n", s.Name))
				buf.WriteString("	}\n")
			} else {
				return "", fmt.Errorf("unsupported map key type for top-level map: %v", keyType.Kind())
			}

		default:
			return "", fmt.Errorf("unsupported basic type for schema generation: %v", s.Type.Kind())
		}
		buf.WriteString("	return nil\n")
		buf.WriteString("}\n\n")
		return buf.String(), nil
	}

	buf.WriteString("	if node.Type == ir.NullType {\n")
	buf.WriteString("		return nil\n")
	buf.WriteString("	}\n")
	buf.WriteString("	if node.Type != ir.ObjectType {\n")
	buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected map for %s, got %%v\", node.Type)\n", s.Name))
	buf.WriteString("	}\n\n")

	// Track required fields
	for _, field := range s.Fields {
		if field.Required && !field.Omit {
			buf.WriteString(fmt.Sprintf("	var found_%s bool\n", field.Name))
		}
	}

	buf.WriteString("	for i, fieldName := range node.Fields {\n")
	buf.WriteString("		fieldNode := node.Values[i]\n")
	buf.WriteString("		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)\n")
	buf.WriteString("		fieldNodeUnwrapped := fieldNode\n")
	buf.WriteString("		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {\n")
	buf.WriteString("			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]\n")
	buf.WriteString("		}\n")
	buf.WriteString("		switch fieldName.String {\n")

	// Get struct fields from schema using GetStructFields
	// For now, we'll iterate over StructInfo.Fields
	for _, field := range s.Fields {
		if field.Omit {
			continue
		}

		// Get schema field name
		schemaFieldName := field.SchemaFieldName
		if schemaFieldName == "" {
			schemaFieldName = field.Name
		}

		buf.WriteString(fmt.Sprintf("		case %q:\n", schemaFieldName))

		// Generate code to decode field
		fieldCode, err := generateFieldDecoding(s, field, schemaFieldName, currentPkgPath)
		if err != nil {
			return "", fmt.Errorf("failed to generate field decoding for %q: %w", field.Name, err)
		}
		buf.WriteString(fieldCode)

		if field.Required {
			buf.WriteString(fmt.Sprintf("			found_%s = true\n", field.Name))
		}
	}

	buf.WriteString("		}\n")
	buf.WriteString("	}\n\n")

	// Check required fields
	for _, field := range s.Fields {
		if field.Required && !field.Omit {
			schemaFieldName := field.SchemaFieldName
			if schemaFieldName == "" {
				schemaFieldName = field.Name
			}

			buf.WriteString(fmt.Sprintf("	if !found_%s {\n", field.Name))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"required field %%q is missing\", %q)\n", schemaFieldName))
			buf.WriteString("	}\n")
		}
	}

	// Handle allowExtra flag
	if s.StructSchema != nil && s.StructSchema.AllowExtra {
		buf.WriteString("	// allowExtra is true, so extra fields are ignored\n")
	} else {
		// Validate no extra fields (optional - can be added later)
	}

	buf.WriteString("	return nil\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// GenerateToTonyMethod generates a ToTony() method for a struct.
func GenerateToTonyMethod(structInfo *StructInfo) (string, error) {
	var buf strings.Builder

	// Method signature
	buf.WriteString(fmt.Sprintf("// ToTony converts %s to Tony format bytes.\n", structInfo.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) ToTony(opts ...gomap.MapOption) ([]byte, error) {\n", structInfo.Name))
	buf.WriteString("	node, err := s.ToTonyIR(opts...)\n")
	buf.WriteString("	if err != nil {\n")
	buf.WriteString("		return nil, err\n")
	buf.WriteString("	}\n")
	buf.WriteString("	var buf bytes.Buffer\n")
	buf.WriteString("	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {\n")
	buf.WriteString("		return nil, err\n")
	buf.WriteString("	}\n")
	buf.WriteString("	return buf.Bytes(), nil\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// GenerateFromTonyMethod generates a FromTony() method for a struct.
func GenerateFromTonyMethod(structInfo *StructInfo) (string, error) {
	var buf strings.Builder

	// Method signature
	buf.WriteString(fmt.Sprintf("// FromTony parses Tony format bytes and populates %s.\n", structInfo.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) FromTony(data []byte, opts ...gomap.UnmapOption) error {\n", structInfo.Name))
	buf.WriteString("	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)\n")
	buf.WriteString("	if err != nil {\n")
	buf.WriteString("		return err\n")
	buf.WriteString("	}\n")
	buf.WriteString("	return s.FromTonyIR(node, opts...)\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// getTypeName returns the type name for code generation.
// Uses StructTypeName if available (for struct types), otherwise uses Type.Name().
func getTypeName(typ reflect.Type, structTypeName string) string {
	if structTypeName != "" {
		return structTypeName
	}
	return typ.Name()
}

// getMapValueTypeName returns the proper type name for map value types.
// It checks field.StructTypeName first (which contains the value type name for maps),
// then field.TypeName, and falls back to getQualifiedTypeName with recovery logic.
func getMapValueTypeName(field *FieldInfo, valueType reflect.Type, currentPkgPath string) string {
	isPtr := valueType.Kind() == reflect.Ptr

	// Use stored struct type name if available
	if field.StructTypeName != "" {
		if isPtr {
			return "*" + field.StructTypeName
		}
		return field.StructTypeName
	}

	// Use TypeName if available (for named types)
	if field.TypeName != "" {
		name := field.TypeName
		if field.TypePkgPath != "" && field.TypePkgPath != currentPkgPath {
			pkgParts := strings.Split(field.TypePkgPath, "/")
			name = pkgParts[len(pkgParts)-1] + "." + name
		}
		if isPtr {
			return "*" + name
		}
		return name
	}

	// Fallback to getQualifiedTypeName
	structName := getQualifiedTypeName(valueType, currentPkgPath)

	// Try to recover from String() if we got "struct"
	if structName != "struct" && structName != "*struct" && structName != "" {
		return structName
	}

	elemType := valueType
	if isPtr {
		elemType = valueType.Elem()
	}
	if elemType.Kind() != reflect.Struct {
		return structName
	}

	typeStr := elemType.String()
	if typeStr == "struct" || strings.HasPrefix(typeStr, "struct {") {
		return structName
	}

	// Extract name from String() representation
	recoveredName := typeStr
	if strings.Contains(typeStr, ".") {
		parts := strings.Split(typeStr, ".")
		recoveredName = parts[len(parts)-1]
		if elemType.PkgPath() != "" && elemType.PkgPath() != currentPkgPath {
			pkgParts := strings.Split(elemType.PkgPath(), "/")
			recoveredName = pkgParts[len(pkgParts)-1] + "." + recoveredName
		}
	}

	if isPtr {
		return "*" + recoveredName
	}
	return recoveredName
}

// getQualifiedTypeName returns the qualified type name for code generation.
// It handles cross-package references by using the package name.
func getQualifiedTypeName(typ reflect.Type, currentPkg string) string {
	if typ == nil {
		return ""
	}

	// Named types - Check this FIRST to avoid infinite recursion for recursive types
	if typ.Name() != "" {
		if typ.PkgPath() != "" && typ.PkgPath() != currentPkg {
			// External package
			// We need the package name, which is the last part of the path
			// This is a heuristic; ideally we'd have a map of path -> name
			parts := strings.Split(typ.PkgPath(), "/")
			pkgName := parts[len(parts)-1]
			return pkgName + "." + typ.Name()
		}
		return typ.Name()
	}

	// For struct types without a name, try to extract from String()
	// This handles cases where Name() returns empty but String() has the type info
	if typ.Kind() == reflect.Struct && typ.Name() == "" {
		typeStr := typ.String()
		// String() for named structs can return:
		// - "package.TypeName" for external packages (e.g., "storage.PendingFileRef")
		// - "TypeName" for same package (e.g., "PendingFileRef")
		// - "struct {...}" for anonymous structs
		
		// Skip anonymous structs
		if strings.HasPrefix(typeStr, "struct {") {
			return "struct" // Will cause compile error
		}
		
		// If String() contains a dot, extract type name
		if strings.Contains(typeStr, ".") {
			parts := strings.Split(typeStr, ".")
			typeName := parts[len(parts)-1]
			// Check if it's in the current package
			if typ.PkgPath() != "" && typ.PkgPath() == currentPkg {
				return typeName
			}
			// External package - use package name from PkgPath or String()
			if typ.PkgPath() != "" {
				pkgParts := strings.Split(typ.PkgPath(), "/")
				pkgName := pkgParts[len(pkgParts)-1]
				return pkgName + "." + typeName
			}
			// Fallback: use package from String()
			if len(parts) >= 2 {
				pkgName := parts[len(parts)-2]
				return pkgName + "." + typeName
			}
			return typeName
		}
		
		// If String() has no dot but PkgPath is set, it's likely same package
		// Use String() as the type name (it should be just the type name)
		if typ.PkgPath() != "" && typ.PkgPath() == currentPkg && typeStr != "struct" {
			return typeStr
		}
		
		// If PkgPath is set, try to construct the name
		if typ.PkgPath() != "" && typeStr != "struct" && typeStr != "" {
			// Check if it's current package
			if typ.PkgPath() == currentPkg {
				return typeStr
			}
			// External package
			pkgParts := strings.Split(typ.PkgPath(), "/")
			pkgName := pkgParts[len(pkgParts)-1]
			return pkgName + "." + typeStr
		}
		
		// Fallback: return "struct" which will cause a compile error
		return "struct"
	}

	// Handle pointers
	if typ.Kind() == reflect.Ptr {
		return "*" + getQualifiedTypeName(typ.Elem(), currentPkg)
	}

	// Handle slices
	if typ.Kind() == reflect.Slice {
		return "[]" + getQualifiedTypeName(typ.Elem(), currentPkg)
	}

	// Handle arrays
	if typ.Kind() == reflect.Array {
		return fmt.Sprintf("[%d]%s", typ.Len(), getQualifiedTypeName(typ.Elem(), currentPkg))
	}

	// Handle maps
	if typ.Kind() == reflect.Map {
		return fmt.Sprintf("map[%s]%s", getQualifiedTypeName(typ.Key(), currentPkg), getQualifiedTypeName(typ.Elem(), currentPkg))
	}

	// Handle struct types - if Name() is empty, try to extract from String()
	if typ.Kind() == reflect.Struct {
		// For struct types, String() returns the full qualified name (e.g., "storage.PendingFileRef")
		// or just the type name if in the same package (e.g., "PendingFileRef")
		typeStr := typ.String()
		// If String() contains a dot, it's a qualified name - use it as-is
		if strings.Contains(typeStr, ".") {
			// Extract just the type name part (after the last dot)
			parts := strings.Split(typeStr, ".")
			return parts[len(parts)-1]
		}
		// If no dot, String() should just be the type name
		if typeStr != "struct" && typeStr != "" {
			return typeStr
		}
		// Fallback: this is likely an anonymous struct
		return "struct" // This will cause a compile error, which is better than silent failure
	}

	// Basic types
	return typ.Kind().String()
}

// generateFieldDecoding generates code to decode a field from an IR node.
func generateFieldDecoding(structInfo *StructInfo, field *FieldInfo, schemaFieldName string, currentPkgPath string) (string, error) {
	var buf strings.Builder

	// Special handling for *ir.Node (and deeper pointers)
	if depth := getIRNodeDepth(field.Type); depth > 0 {
		// Use fieldNode (preserves comments) or fieldNodeUnwrapped (strips comments) based on option
		buf.WriteString("	if gomap.GetUnmapComments(opts...) {\n")
		if depth == 1 {
			buf.WriteString(fmt.Sprintf("		s.%s = fieldNode\n", field.Name))
		} else {
			buf.WriteString("		v0 := fieldNode\n")
			for i := 1; i < depth; i++ {
				buf.WriteString(fmt.Sprintf("		v%d := &v%d\n", i, i-1))
			}
			buf.WriteString(fmt.Sprintf("		s.%s = v%d\n", field.Name, depth-1))
		}
		buf.WriteString("	} else {\n")
		if depth == 1 {
			buf.WriteString(fmt.Sprintf("		s.%s = fieldNodeUnwrapped\n", field.Name))
		} else {
			buf.WriteString("		v0 := fieldNodeUnwrapped\n")
			for i := 1; i < depth; i++ {
				buf.WriteString(fmt.Sprintf("		v%d := &v%d\n", i, i-1))
			}
			buf.WriteString(fmt.Sprintf("		s.%s = v%d\n", field.Name, depth-1))
		}
		buf.WriteString("	}\n")
		return buf.String(), nil
	}

	// Check for encoding.TextUnmarshaler using the flag set during type resolution
	// We use the flag instead of runtime reflection because custom types like `type A int`
	// don't preserve methods in reflect.Type
	if field.ImplementsTextUnmarshaler {
		if field.Type.Kind() != reflect.Ptr {
			// Value type implementing TextUnmarshaler (via pointer receiver)
			buf.WriteString("	if fieldNodeUnwrapped.Type != ir.StringType {\n")
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"field %%q: expected string for TextUnmarshaler, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	if err := s.%s.UnmarshalText([]byte(fieldNodeUnwrapped.String)); err != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"field %%q: failed to unmarshal text: %%w\", %q, err)\n", schemaFieldName))
			buf.WriteString("	}\n")
			return buf.String(), nil
		} else {
			// Pointer type implementing TextUnmarshaler
			buf.WriteString("	if fieldNodeUnwrapped.Type == ir.NullType {\n")
			buf.WriteString(fmt.Sprintf("		s.%s = nil\n", field.Name))
			buf.WriteString("	} else if fieldNodeUnwrapped.Type != ir.StringType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: expected string for TextUnmarshaler, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
			buf.WriteString("	} else {\n")
			buf.WriteString(fmt.Sprintf("		if s.%s == nil {\n", field.Name))
			// Use getQualifiedTypeName to handle all type cases correctly
			typeName := getQualifiedTypeName(field.Type.Elem(), currentPkgPath)
			buf.WriteString(fmt.Sprintf("			s.%s = new(%s)\n", field.Name, typeName))
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		if err := s.%s.UnmarshalText([]byte(fieldNodeUnwrapped.String)); err != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: failed to unmarshal text: %%w\", %q, err)\n", schemaFieldName))
			buf.WriteString("		}\n")
			buf.WriteString("	}\n")
			return buf.String(), nil
		}
	}

	// Field comment
	buf.WriteString(fmt.Sprintf("	// Field: %s\n", field.Name))

	// Handle different field types
	switch field.Type.Kind() {
	case reflect.String:
		buf.WriteString("	if fieldNodeUnwrapped.Type != ir.StringType {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: expected string, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
		buf.WriteString("	}\n")
		buf.WriteString(fmt.Sprintf("	s.%s = fieldNodeUnwrapped.String\n", field.Name))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString("	if fieldNodeUnwrapped.Int64 == nil {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
		buf.WriteString("	}\n")
		// Handle overflow checking for smaller int types
		intVal := "*fieldNodeUnwrapped.Int64"
		if field.Type.Kind() == reflect.Int8 {
			buf.WriteString(fmt.Sprintf("	if %s < -128 || %s > 127 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: value %%d overflows int8\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("	}\n")
		} else if field.Type.Kind() == reflect.Int16 {
			buf.WriteString(fmt.Sprintf("	if %s < -32768 || %s > 32767 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: value %%d overflows int16\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("	}\n")
		} else if field.Type.Kind() == reflect.Int32 {
			buf.WriteString(fmt.Sprintf("	if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: value %%d overflows int32\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("	}\n")
		}
		// Handle time.Duration specially (it's an int64 alias)
		// Check if this is time.Duration by checking type string, PkgPath/Name, or StructTypeName
		typeName := field.Type.Name()
		typeStr := field.Type.String()
		
		// Check type string first (most reliable for type aliases)
		if typeStr == "time.Duration" {
			typeName = "time.Duration"
		} else if field.StructTypeName != "" && (field.StructTypeName == "time.Duration" || field.StructTypeName == "Duration") {
			// Use StructTypeName if it's set and indicates time.Duration
			if field.StructTypeName == "Duration" && field.Type.PkgPath() == "time" {
				typeName = "time.Duration"
			} else if field.StructTypeName == "time.Duration" {
				typeName = "time.Duration"
			} else {
				typeName = field.StructTypeName
			}
		} else if field.Type.PkgPath() == "time" && typeName == "Duration" {
			typeName = "time.Duration"
		} else if typeName == "" {
			// Fallback to qualified type name for other named types
			typeName = getQualifiedTypeName(field.Type, currentPkgPath)
		} else if field.Type.PkgPath() != "" && field.Type.PkgPath() != currentPkgPath {
			// External package type - qualify it
			parts := strings.Split(field.Type.PkgPath(), "/")
			pkgName := parts[len(parts)-1]
			typeName = pkgName + "." + typeName
		}
		buf.WriteString(fmt.Sprintf("	s.%s = %s(%s)\n", field.Name, typeName, intVal))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString("	if fieldNodeUnwrapped.Int64 == nil {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
		buf.WriteString("	}\n")
		// Check for negative values and overflow
		intVal := "*fieldNodeUnwrapped.Int64"
		buf.WriteString(fmt.Sprintf("	if %s < 0 {\n", intVal))
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: negative value %%d for unsigned type\", %q, %s)\n", schemaFieldName, intVal))
		buf.WriteString("	}\n")
		if field.Type.Kind() == reflect.Uint8 {
			buf.WriteString(fmt.Sprintf("	if %s > 255 {\n", intVal))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: value %%d overflows uint8\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("	}\n")
		} else if field.Type.Kind() == reflect.Uint16 {
			buf.WriteString(fmt.Sprintf("	if %s > 65535 {\n", intVal))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: value %%d overflows uint16\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("	}\n")
		} else if field.Type.Kind() == reflect.Uint32 {
			buf.WriteString(fmt.Sprintf("	if %s > 4294967295 {\n", intVal))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: value %%d overflows uint32\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("	}\n")
		}
		buf.WriteString(fmt.Sprintf("	s.%s = %s(%s)\n", field.Name, field.Type.Name(), intVal))

	case reflect.Float32, reflect.Float64:
		buf.WriteString("	if fieldNodeUnwrapped.Float64 == nil {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
		buf.WriteString("	}\n")
		buf.WriteString(fmt.Sprintf("	s.%s = %s(*fieldNodeUnwrapped.Float64)\n", field.Name, field.Type.Name()))

	case reflect.Bool:
		buf.WriteString("	if fieldNodeUnwrapped.Type != ir.BoolType {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: expected bool, got %%v\", %q, fieldNodeUnwrapped.Type)\n", schemaFieldName))
		buf.WriteString("	}\n")
		buf.WriteString(fmt.Sprintf("	s.%s = fieldNodeUnwrapped.Bool\n", field.Name))

	case reflect.Ptr:
		// Pointer type
		elemType := field.Type.Elem()
		if elemType.Kind() == reflect.Struct {
			// Pointer to struct - call FromTony()
			structName := getQualifiedTypeName(elemType, currentPkgPath)
			buf.WriteString(fmt.Sprintf("	s.%s = &%s{}\n", field.Name, structName))
			buf.WriteString(fmt.Sprintf("	if err := s.%s.FromTonyIR(fieldNode%s); err != nil {\n", field.Name, fromTonyIROptsSuffix(elemType, currentPkgPath)))
			buf.WriteString("		return err\n")
			buf.WriteString("	}\n")
		} else {
			// Pointer to primitive (or named basic type like format.Format)
			// First check for null - leave pointer as nil
			buf.WriteString("	if fieldNodeUnwrapped.Type == ir.NullType {\n")
			buf.WriteString("		// null value - leave pointer as nil\n")
			buf.WriteString("	} else {\n")
			typeName := getQualifiedTypeName(elemType, currentPkgPath)
			buf.WriteString(fmt.Sprintf("		val := new(%s)\n", typeName))

			// Generate validation and extraction based on underlying type
			switch elemType.Kind() {
			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
				buf.WriteString("	if fieldNodeUnwrapped.Int64 == nil {\n")
				buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: expected number, got %%v\", %q, fieldNodeUnwrapped.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("	}\n")
				// Handle overflow checking for smaller int types
				intVal := "*fieldNodeUnwrapped.Int64"
				if elemType.Kind() == reflect.Int8 {
					buf.WriteString(fmt.Sprintf("	if %s < -128 || %s > 127 {\n", intVal, intVal))
					buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: value %%d overflows int8\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("	}\n")
				} else if elemType.Kind() == reflect.Int16 {
					buf.WriteString(fmt.Sprintf("	if %s < -32768 || %s > 32767 {\n", intVal, intVal))
					buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: value %%d overflows int16\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("	}\n")
				} else if elemType.Kind() == reflect.Int32 {
					buf.WriteString(fmt.Sprintf("	if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
					buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: value %%d overflows int32\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("	}\n")
				}
				buf.WriteString(fmt.Sprintf("	*val = %s(%s)\n", typeName, intVal))
			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
				buf.WriteString("	if fieldNodeUnwrapped.Int64 == nil {\n")
				buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: expected number, got %%v\", %q, fieldNodeUnwrapped.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("	}\n")
				// Check for negative values and overflow
				intVal := "*fieldNodeUnwrapped.Int64"
				buf.WriteString(fmt.Sprintf("	if %s < 0 {\n", intVal))
				buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: negative value %%d for unsigned type\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
				buf.WriteString("	}\n")
				if elemType.Kind() == reflect.Uint8 {
					buf.WriteString(fmt.Sprintf("	if %s > 255 {\n", intVal))
					buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: value %%d overflows uint8\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("	}\n")
				} else if elemType.Kind() == reflect.Uint16 {
					buf.WriteString(fmt.Sprintf("	if %s > 65535 {\n", intVal))
					buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: value %%d overflows uint16\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("	}\n")
				} else if elemType.Kind() == reflect.Uint32 {
					buf.WriteString(fmt.Sprintf("	if %s > 4294967295 {\n", intVal))
					buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: value %%d overflows uint32\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("	}\n")
				}
				buf.WriteString(fmt.Sprintf("	*val = %s(%s)\n", typeName, intVal))
			case reflect.Float32, reflect.Float64:
				buf.WriteString("	if fieldNodeUnwrapped.Float64 == nil {\n")
				buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: expected number, got %%v\", %q, fieldNodeUnwrapped.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("	}\n")
				buf.WriteString(fmt.Sprintf("	*val = %s(*fieldNodeUnwrapped.Float64)\n", typeName))
			case reflect.String:
				buf.WriteString("	if fieldNodeUnwrapped.Type != ir.StringType {\n")
				buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: expected string, got %%v\", %q, fieldNodeUnwrapped.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("	}\n")
				buf.WriteString(fmt.Sprintf("	*val = %s(fieldNodeUnwrapped.String)\n", typeName))
			case reflect.Bool:
				buf.WriteString("	if fieldNodeUnwrapped.Type != ir.BoolType {\n")
				buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"%%s: expected bool, got %%v\", %q, fieldNodeUnwrapped.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("	}\n")
				buf.WriteString(fmt.Sprintf("	*val = %s(fieldNodeUnwrapped.Bool)\n", typeName))
			default:
				return "", fmt.Errorf("unsupported pointer to primitive type: %v", elemType.Kind())
			}

			buf.WriteString(fmt.Sprintf("		s.%s = val\n", field.Name))
			buf.WriteString("	}\n") // close the else block for null check
		}

	case reflect.Slice, reflect.Array:
		// Slice/Array type
		elemType := field.Type.Elem()
		buf.WriteString("	if fieldNodeUnwrapped.Type == ir.ArrayType {\n")
		// Get the type name for the slice element
		// If field.StructTypeName is set, use it (it contains the named type, not the underlying type)
		// Also check field.TypeName as a fallback
		var structName string
		if field.StructTypeName != "" {
			// Use the stored struct type name - it's already qualified if needed
			structName = field.StructTypeName
			// If elemType is a pointer, add the * prefix
			if elemType.Kind() == reflect.Ptr {
				structName = "*" + structName
			}
		} else if field.TypeName != "" {
			// Use TypeName if available (for named types)
			structName = field.TypeName
			// Add package prefix if it's from another package
			if field.TypePkgPath != "" && field.TypePkgPath != currentPkgPath {
				pkgParts := strings.Split(field.TypePkgPath, "/")
				pkgName := pkgParts[len(pkgParts)-1]
				structName = pkgName + "." + structName
			}
			// If elemType is a pointer, add the * prefix
			if elemType.Kind() == reflect.Ptr {
				structName = "*" + structName
			}
		} else {
			// Fallback to extracting from reflect.Type
			structName = getQualifiedTypeName(elemType, currentPkgPath)
			// If we got "struct", the type name extraction failed - try to recover from String()
			// This can happen when Name() returns empty but String() has the type info
			if (structName == "struct" || structName == "") && elemType.Kind() == reflect.Struct {
				typeStr := elemType.String()
				// String() for named structs returns "package.TypeName" (e.g., "storage.PendingFileRef")
				// or "TypeName" for same package, or "struct {...}" for anonymous structs
				if typeStr != "struct" && !strings.HasPrefix(typeStr, "struct {") {
					// Extract type name from String()
					if strings.Contains(typeStr, ".") {
						parts := strings.Split(typeStr, ".")
						structName = parts[len(parts)-1]
						// If PkgPath matches currentPkg, we don't need the package prefix
						if elemType.PkgPath() != "" && elemType.PkgPath() == currentPkgPath {
							// Already extracted just the name, use it as-is
						} else if elemType.PkgPath() != "" {
							// External package - add package name
							pkgParts := strings.Split(elemType.PkgPath(), "/")
							pkgName := pkgParts[len(pkgParts)-1]
							structName = pkgName + "." + structName
						}
					} else {
						// No dot means same package - use String() directly
						structName = typeStr
					}
				} else {
					// String() is "struct" or "struct {...}" - this is an anonymous struct
					// We can't generate proper code for this, but at least try to use String()
					// which will cause a compile error (better than silent failure)
				}
			}
		}
		buf.WriteString(fmt.Sprintf("		slice := make([]%s, len(fieldNodeUnwrapped.Values))\n", structName))
		buf.WriteString("		for i, v := range fieldNodeUnwrapped.Values {\n")
		if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) {
			// Slice of structs or pointers to structs - call FromTony()
			// Need to handle both struct values and pointers
			if elemType.Kind() == reflect.Ptr {
				// Element is already a pointer, allocate new instance
				// structName has the * prefix (e.g., "*api.Patch"), but new() needs the base type (e.g., "api.Patch")
				// So we need to remove the * prefix if it exists
				baseTypeName := structName
				if strings.HasPrefix(baseTypeName, "*") {
					baseTypeName = baseTypeName[1:]
				}
				buf.WriteString(fmt.Sprintf("			elem := new(%s)\n", baseTypeName))
				buf.WriteString(fmt.Sprintf("			if err := elem.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(elemType.Elem(), currentPkgPath)))
				buf.WriteString("				return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
				buf.WriteString("			}\n")
				buf.WriteString("			slice[i] = elem\n")
			} else {
				// Element is a struct value
				buf.WriteString(fmt.Sprintf("			elem := %s{}\n", structName))
				buf.WriteString(fmt.Sprintf("			if err := elem.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(elemType, currentPkgPath)))
				buf.WriteString("				return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
				buf.WriteString("			}\n")
				buf.WriteString("			slice[i] = elem\n")
			}
		} else {
			// Slice of primitives
			// Generate code with a context variable that will be formatted
			buf.WriteString("			ctx := fmt.Sprintf(\"slice element %d\", i)\n")
			elemCode, err := generatePrimitiveFromIR("v", elemType, "ctx")
			if err != nil {
				return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
			}
			buf.WriteString(fmt.Sprintf("			var elem %s\n", getQualifiedTypeName(elemType, currentPkgPath)))
			buf.WriteString(fmt.Sprintf("			%s\n", elemCode))
			buf.WriteString("			slice[i] = elem\n")
		}
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = slice\n", field.Name))
		buf.WriteString("	}\n")

	case reflect.Map:
		// Map type
		keyType := field.Type.Key()
		valueType := field.Type.Elem()

		if keyType.Kind() == reflect.Uint32 {
			// Sparse array (map[uint32]T)
			buf.WriteString("	if fieldNodeUnwrapped.Type == ir.ObjectType && fieldNodeUnwrapped.Tag == \"!sparsearray\" {\n")
			structName := getMapValueTypeName(field, valueType, currentPkgPath)
			buf.WriteString(fmt.Sprintf("		m := make(map[uint32]%s)\n", structName))
			buf.WriteString("		irMap := ir.ToMap(fieldNodeUnwrapped)\n")
			buf.WriteString("		for kStr, v := range irMap {\n")
			buf.WriteString("			k, err := strconv.ParseUint(kStr, 10, 32)\n")
			buf.WriteString("			if err != nil {\n")
			buf.WriteString("				return fmt.Errorf(\"invalid sparse array key %q: %w\", kStr, err)\n")
			buf.WriteString("			}\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				// Map value is struct or pointer to struct
				if valueType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("			val := new(%s)\n", strings.TrimPrefix(structName, "*")))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[uint32(k)] = val\n")
				} else {
					buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[uint32(k)] = val\n")
				}
			} else {
				buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %d\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
				buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
				buf.WriteString("			m[uint32(k)] = val\n")
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		s.%s = m\n", field.Name))
			buf.WriteString("	}\n")
		} else if keyType.Kind() == reflect.String {
			// Regular map (map[string]T)
			buf.WriteString("	if fieldNodeUnwrapped.Type == ir.ObjectType {\n")
			structName := getMapValueTypeName(field, valueType, currentPkgPath)
			if depth := getIRNodeDepth(valueType); depth > 0 {
				structName = "*ir.Node"
			}
			buf.WriteString(fmt.Sprintf("		m := make(map[string]%s)\n", structName))
			buf.WriteString("		irMap := ir.ToMap(fieldNodeUnwrapped)\n")
			buf.WriteString("		for k, v := range irMap {\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				// Map value is struct or pointer to struct
				if valueType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("			val := new(%s)\n", strings.TrimPrefix(structName, "*")))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[k] = val\n")
				} else {
					buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[k] = val\n")
				}
			} else if depth := getIRNodeDepth(valueType); depth > 0 {
				if depth == 1 {
					buf.WriteString("			m[k] = v\n")
				} else {
					// We need to create a chain of pointers
					buf.WriteString("			v0 := v\n")
					for j := 1; j < depth; j++ {
						buf.WriteString(fmt.Sprintf("			v%d := &v%d\n", j, j-1))
					}
					buf.WriteString(fmt.Sprintf("			m[k] = v%d\n", depth-1))
				}
			} else {
				buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %q\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
				buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
				buf.WriteString("			m[k] = val\n")
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		s.%s = m\n", field.Name))
			buf.WriteString("	}\n")
		} else if keyType.Kind() == reflect.Interface {
			// Map with interface{} (any) keys - keys were converted to strings
			buf.WriteString("	if fieldNodeUnwrapped.Type == ir.ObjectType {\n")
			structName := getMapValueTypeName(field, valueType, currentPkgPath)
			buf.WriteString(fmt.Sprintf("		m := make(map[interface{}]%s)\n", structName))
			buf.WriteString("		irMap := ir.ToMap(fieldNodeUnwrapped)\n")
			buf.WriteString("		for kStr, v := range irMap {\n")
			buf.WriteString("			// Convert string key back to interface{}\n")
			buf.WriteString("			var k interface{} = kStr\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				// Map value is struct or pointer to struct
				if valueType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("			val := new(%s)\n", strings.TrimPrefix(structName, "*")))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"map value at key %v: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[k] = val\n")
				} else {
					buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"map value at key %v: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[k] = val\n")
				}
			} else {
				buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %v\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
				buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
				buf.WriteString("			m[k] = val\n")
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		s.%s = m\n", field.Name))
			buf.WriteString("	}\n")
		} else if keyType.Kind() == reflect.Ptr {
			// Map with pointer keys - keys were converted to strings (pointer addresses)
			// Note: We can't reconstruct the original pointer from the address string,
			// so this is a lossy conversion. The pointer address is preserved as a string.
			buf.WriteString("	// Note: Pointer keys cannot be fully reconstructed from serialized form\n")
			buf.WriteString("	// Pointer addresses are preserved as strings, but original pointers are lost\n")
			buf.WriteString("	if fieldNodeUnwrapped.Type == ir.ObjectType {\n")
			structName := getMapValueTypeName(field, valueType, currentPkgPath)
			elemType := keyType.Elem()
			// Extract key struct name from AST if available (for pointer keys like *X)
			keyStructNameFromAST := ""
			if field.ASTType != nil {
				if mapType, ok := field.ASTType.(*ast.MapType); ok {
					if keyIdent, ok := mapType.Key.(*ast.StarExpr); ok {
						if ident, ok := keyIdent.X.(*ast.Ident); ok {
							keyStructNameFromAST = ident.Name
						}
					}
				}
			}
			// Use AST name if available, otherwise try type name, fallback to interface{}
			keyStructName := keyStructNameFromAST
			if keyStructName == "" {
				keyStructName = elemType.Name()
			}
			if keyStructName == "" {
				keyStructName = "interface{}"
			}
			buf.WriteString(fmt.Sprintf("		m := make(map[*%s]%s)\n", keyStructName, structName))
			buf.WriteString("		irMap := ir.ToMap(fieldNodeUnwrapped)\n")
			buf.WriteString("		for kStr, v := range irMap {\n")
			buf.WriteString("			// Parse pointer address from string (format: 0x...)\n")
			buf.WriteString("			var ptrAddr uintptr\n")
			buf.WriteString("			if _, err := fmt.Sscanf(kStr, \"0x%%x\", &ptrAddr); err != nil {\n")
			buf.WriteString("				return fmt.Errorf(\"invalid pointer address format %%q: %%w\", kStr, err)\n")
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			k := (*%s)(unsafe.Pointer(ptrAddr))\n", keyStructName))
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				// Map value is struct or pointer to struct
				if valueType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("			val := new(%s)\n", strings.TrimPrefix(structName, "*")))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType.Elem(), currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"map value at key %p: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[k] = val\n")
				} else {
					buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
					buf.WriteString(fmt.Sprintf("			if err := val.FromTonyIR(v%s); err != nil {\n", fromTonyIROptsSuffix(valueType, currentPkgPath)))
					buf.WriteString("				return fmt.Errorf(\"map value at key %p: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			m[k] = val\n")
				}
			} else {
				buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %p\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
				buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
				buf.WriteString("			m[k] = val\n")
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		s.%s = m\n", field.Name))
			buf.WriteString("	}\n")
		} else {
			return "", fmt.Errorf("unsupported map key type: %v (only string, uint32, interface{}, and pointer types are supported)", keyType.Kind())
		}

	case reflect.Interface:
		// Interface{} type - use reflection-based conversion
		buf.WriteString(fmt.Sprintf("	// Interface{} conversion requires runtime reflection\n"))
		buf.WriteString(fmt.Sprintf("	if err := fromIRInterface(fieldNode, &s.%s); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: %%w\", %q, err)\n", schemaFieldName))
		buf.WriteString("	}\n")

	case reflect.Struct:
		// Nested struct - call FromTony()
		buf.WriteString(fmt.Sprintf("	if err := s.%s.FromTonyIR(fieldNode); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"field %%q: %%w\", %q, err)\n", schemaFieldName))
		buf.WriteString("	}\n")

	default:
		return "", fmt.Errorf("unsupported field type: %v", field.Type.Kind())
	}

	return buf.String(), nil
}

// generatePrimitiveFromIR generates code to extract a primitive value from an IR node.
// Returns the code statement (e.g., "if v.Type != ir.StringType { return fmt.Errorf(...) }; elem = v.String").
// The context parameter can contain format specifiers like %d, %q, etc. that will be used in error messages.
func generatePrimitiveFromIR(varName string, typ reflect.Type, context string) (string, error) {
	var buf strings.Builder

	switch typ.Kind() {
	case reflect.String:
		buf.WriteString(fmt.Sprintf("if %s.Type != ir.StringType {\n", varName))
		// Use %q to properly quote the context string in the error message
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected string, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s.String", varName))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString(fmt.Sprintf("if %s.Int64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		intVal := fmt.Sprintf("*%s.Int64", varName)
		// Overflow checking
		if typ.Kind() == reflect.Int8 {
			buf.WriteString(fmt.Sprintf("if %s < -128 || %s > 127 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int8\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Int16 {
			buf.WriteString(fmt.Sprintf("if %s < -32768 || %s > 32767 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int16\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Int32 {
			buf.WriteString(fmt.Sprintf("if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int32\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		}
		buf.WriteString(fmt.Sprintf("elem = %s(%s)", typ.Name(), intVal))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString(fmt.Sprintf("if %s.Int64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		intVal := fmt.Sprintf("*%s.Int64", varName)
		buf.WriteString(fmt.Sprintf("if %s < 0 {\n", intVal))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: negative value %%d for unsigned type\", %s, %s)\n", context, intVal))
		buf.WriteString("}\n")
		if typ.Kind() == reflect.Uint8 {
			buf.WriteString(fmt.Sprintf("if %s > 255 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint8\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Uint16 {
			buf.WriteString(fmt.Sprintf("if %s > 65535 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint16\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Uint32 {
			buf.WriteString(fmt.Sprintf("if %s > 4294967295 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint32\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		}
		buf.WriteString(fmt.Sprintf("elem = %s(%s)", typ.Name(), intVal))

	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("if %s.Float64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s(*%s.Float64)", typ.Name(), varName))

	case reflect.Bool:
		buf.WriteString(fmt.Sprintf("if %s.Type != ir.BoolType {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected bool, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s.Bool", varName))

	default:
		return "", fmt.Errorf("unsupported primitive type: %v", typ.Kind())
	}

	return buf.String(), nil
}

// isPrimitiveKind checks if a kind is a primitive type (bool, int*, uint*, float*, string)
func isPrimitiveKind(k reflect.Kind) bool {
	switch k {
	case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64, reflect.String:
		return true
	default:
		return false
	}
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// Helper function to extract assignment from generated code
func extractAssignment(code string) string {
	lines := strings.Split(code, "\n")
	for _, line := range lines {
		if strings.Contains(line, "=") && !strings.Contains(line, "if") && !strings.Contains(line, "return") {
			return strings.TrimSpace(line)
		}
	}
	return ""
}

// HasToTonyMethod checks if a type has a ToTony() method.
func HasToTonyMethod(typ reflect.Type) bool {
	method, ok := typ.MethodByName("ToTony")
	if !ok {
		// Check pointer receiver
		if typ.Kind() != reflect.Ptr {
			ptrType := reflect.PtrTo(typ)
			_, ok = ptrType.MethodByName("ToTony")
		}
		return ok
	}

	// Verify signature: ToTony() (*ir.Node, error)
	if method.Type.NumIn() != 1 || method.Type.NumOut() != 2 {
		return false
	}

	// Check return types
	out0 := method.Type.Out(0)
	out1 := method.Type.Out(1)

	// out0 should be *ir.Node, out1 should be error
	return out0.Kind() == reflect.Ptr && out1.Name() == "error"
}

// HasFromTonyMethod checks if a type has a FromTony() method.
func HasFromTonyMethod(typ reflect.Type) bool {
	method, ok := typ.MethodByName("FromTony")
	if !ok {
		// Check pointer receiver
		if typ.Kind() != reflect.Ptr {
			ptrType := reflect.PtrTo(typ)
			_, ok = ptrType.MethodByName("FromTony")
		}
		return ok
	}

	// Verify signature: FromTony(*ir.Node) error
	if method.Type.NumIn() != 2 || method.Type.NumOut() != 1 {
		return false
	}

	// Check input type (second arg, first is receiver)
	in1 := method.Type.In(1)
	out0 := method.Type.Out(0)

	// in1 should be *ir.Node, out0 should be error
	return in1.Kind() == reflect.Ptr && out0.Name() == "error"
}
