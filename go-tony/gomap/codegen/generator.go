package codegen

import (
	"bytes"
	"encoding"
	"fmt"
	"go/ast"
	"go/format"
	"reflect"
	"sort"
	"strings"

	"github.com/signadot/tony-format/go-tony/schema"
)

var (
	textMarshalerType   = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
	textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
)

// getIRNodeDepth returns the depth of the pointer if the type is a pointer to ir.Node.
// Returns 0 if it's not a pointer to ir.Node.
// e.g. *ir.Node -> 1, **ir.Node -> 2
func getIRNodeDepth(t reflect.Type) int {
	if t == nil {
		return 0
	}
	depth := 0
	current := t
	for current.Kind() == reflect.Ptr {
		depth++
		current = current.Elem()
	}

	// Check if the base type is ir.Node
	if current.Name() == "Node" && strings.HasSuffix(current.PkgPath(), "/ir") {
		return depth
	}
	return 0
}

// isIRNodePtr checks if the type is *ir.Node
// Deprecated: Use getIRNodeDepth instead
func isIRNodePtr(t reflect.Type) bool {
	return getIRNodeDepth(t) == 1
}

// GenerateCode generates Go code for ToTony() and FromTony() methods for all structs.
// Returns formatted Go source code.
func GenerateCode(structs []*StructInfo, schemas map[string]*schema.Schema, config *CodegenConfig) (string, error) {
	var buf strings.Builder

	// Write header
	buf.WriteString("// Code generated by tony-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", config.Package.Name))
	buf.WriteString("import (\n")
	buf.WriteString(`	"bytes"` + "\n")
	buf.WriteString(`	"fmt"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/encode"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/gomap"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/ir"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/parse"` + "\n")

	// Collect external package imports from all structs
	externalImports := make(map[string]bool)
	for _, structInfo := range structs {
		if structInfo.StructSchema == nil {
			continue
		}

		// Helper to collect imports from a type
		var collectImports func(reflect.Type)
		collectImports = func(t reflect.Type) {
			if t == nil {
				return
			}
			// Handle pointers
			for t.Kind() == reflect.Ptr {
				t = t.Elem()
			}

			// Check for named types from other packages
			if t.PkgPath() != "" && t.PkgPath() != config.Package.Path {
				// We need the import path.
				// For now, we rely on the structInfo.Imports map which maps package name to path.
				// But t.PkgPath() IS the import path.
				externalImports[t.PkgPath()] = true
			}

			// Handle containers
			switch t.Kind() {
			case reflect.Slice, reflect.Array:
				collectImports(t.Elem())
			case reflect.Map:
				collectImports(t.Key())
				collectImports(t.Elem())
			case reflect.Struct:
				// For structs, we might need to look up their fields if we were doing deep traversal,
				// but here we only care about the types directly referenced in the generated code.
				// If t is a named struct from another package, we added it above.
			}
		}

		// Check the struct type itself (in case it's a named container type)
		if structInfo.Type != nil {
			collectImports(structInfo.Type)
		}

		// Check all fields for external types
		for _, field := range structInfo.Fields {
			if field.Type != nil {
				collectImports(field.Type)
			}
			// Also check explicit StructTypeName for cases where reflection might be incomplete
			if field.StructTypeName != "" && strings.Contains(field.StructTypeName, ".") {
				// Extract package name (e.g., "format" from "format.Format")
				parts := strings.Split(field.StructTypeName, ".")
				if len(parts) == 2 {
					pkgName := parts[0]
					// Look up the import path from the struct's Imports map
					if importPath, ok := structInfo.Imports[pkgName]; ok {
						externalImports[importPath] = true
					}
				}
			}
		}
	}

	// Add external imports in sorted order for consistency
	var importPaths []string
	for importPath := range externalImports {
		importPaths = append(importPaths, importPath)
	}
	sort.Strings(importPaths)
	for _, importPath := range importPaths {
		buf.WriteString(fmt.Sprintf("\t%q\n", importPath))
	}

	// Check if standard imports are needed
	needsStrconv := false
	needsUnsafe := false

	for _, structInfo := range structs {
		if structInfo.StructSchema == nil {
			continue
		}
		for _, field := range structInfo.Fields {
			if field.Type == nil {
				continue
			}
			// Check for map types that require special handling
			if field.Type.Kind() == reflect.Map {
				keyType := field.Type.Key()
				// map[uint32]T needs strconv for parsing keys
				if keyType.Kind() == reflect.Uint32 {
					needsStrconv = true
				}
				// map[*T]T needs unsafe for pointer keys
				if keyType.Kind() == reflect.Ptr {
					needsUnsafe = true
				}
			}
		}
	}

	// Add other standard imports if needed
	if needsStrconv {
		buf.WriteString(`	"strconv"` + "\n")
	}
	if needsUnsafe {
		buf.WriteString(`	"unsafe"` + "\n")
	}
	buf.WriteString(")\n\n")

	// Generate methods for each struct
	for _, structInfo := range structs {
		// Skip if struct doesn't have schema tag
		if structInfo.StructSchema == nil {
			continue
		}

		// Get schema for this struct
		schemaName := structInfo.StructSchema.SchemaName
		s, ok := schemas[schemaName]
		if !ok {
			return "", fmt.Errorf("schema %q not found for struct %q", schemaName, structInfo.Name)
		}

		// Check if methods already exist (skip code generation if they do)
		// Note: We can't check at codegen time since we're generating the code.
		// This check would need to be done at runtime or via AST analysis.
		// For now, we'll always generate the methods.

		// Generate ToTonyIR method
		toTonyIRCode, err := GenerateToTonyIRMethod(structInfo, s, config.Package.Path)
		if err != nil {
			return "", fmt.Errorf("failed to generate ToTonyIR() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(toTonyIRCode)
		buf.WriteString("\n\n")

		// Generate FromTonyIR method
		fromTonyIRCode, err := GenerateFromTonyIRMethod(structInfo, s, config.Package.Path)
		if err != nil {
			return "", fmt.Errorf("failed to generate FromTonyIR() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(fromTonyIRCode)
		buf.WriteString("\n\n")

		// Generate ToTony method
		toTonyCode, err := GenerateToTonyMethod(structInfo)
		if err != nil {
			return "", fmt.Errorf("failed to generate ToTony() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(toTonyCode)
		buf.WriteString("\n\n")

		// Generate FromTony method
		fromTonyCode, err := GenerateFromTonyMethod(structInfo)
		if err != nil {
			return "", fmt.Errorf("failed to generate FromTony() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(fromTonyCode)
		buf.WriteString("\n\n")
	}

	// Format the generated code
	codeStr := buf.String()
	formatted, err := format.Source([]byte(codeStr))
	if err != nil {
		// Return unformatted code if formatting fails (with error)
		// Include first 50 lines of code for debugging
		lines := strings.Split(codeStr, "\n")
		preview := strings.Join(lines[:min(50, len(lines))], "\n")
		// Show the problematic line if we can extract it from the error
		if len(lines) >= 191 {
			preview += fmt.Sprintf("\n\nLine 191: %s", lines[190])
		}
		return codeStr, fmt.Errorf("failed to format generated code: %w\nFirst 50 lines:\n%s", err, preview)
	}

	return string(formatted), nil
}

// GenerateToTonyIRMethod generates the ToTonyIR method for a struct.
func GenerateToTonyIRMethod(s *StructInfo, sSchema *schema.Schema, currentPkgPath string) (string, error) {
	var buf bytes.Buffer

	// Method signature
	buf.WriteString(fmt.Sprintf("// ToTonyIR converts %s to a Tony IR node.\n", s.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {\n", s.Name))
	buf.WriteString("	if s == nil {\n")
	buf.WriteString("		return ir.Null(), nil\n")
	buf.WriteString("	}\n")

	// Check for TextMarshaler implementation on the type itself
	if s.ImplementsTextMarshaler {
		buf.WriteString("	// Use TextMarshaler implementation\n")
		buf.WriteString("	txt, err := s.MarshalText()\n")
		buf.WriteString("	if err != nil {\n")
		buf.WriteString(fmt.Sprintf("		return nil, fmt.Errorf(\"failed to marshal %s: %%w\", err)\n", s.Name))
		buf.WriteString("	}\n")
		buf.WriteString(fmt.Sprintf("	return ir.FromString(string(txt)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
		buf.WriteString("}\n\n")
		return buf.String(), nil
	}

	// Handle basic types (non-structs)
	if s.Type != nil && s.Type.Kind() != reflect.Struct {
		// Basic type conversion
		switch s.Type.Kind() {
		case reflect.String:
			buf.WriteString(fmt.Sprintf("	return ir.FromString(string(*s)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			buf.WriteString(fmt.Sprintf("	return ir.FromInt(int64(*s)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			// ir.FromInt takes int64, so we might lose precision for uint64 > max int64
			// But for now let's cast to int64
			buf.WriteString(fmt.Sprintf("	return ir.FromInt(int64(*s)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
		case reflect.Float32, reflect.Float64:
			buf.WriteString(fmt.Sprintf("	return ir.FromFloat(float64(*s)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
		case reflect.Bool:
			buf.WriteString(fmt.Sprintf("	return ir.FromBool(bool(*s)).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))

		// Handle container types (Slice, Array, Map)
		case reflect.Slice, reflect.Array:
			// Reuse field generation logic but for the top-level type
			// We create a fake field info to reuse generateFieldToIR logic,
			// but we need to adapt it because generateFieldToIR assumes it's accessing a field of a struct (s.Field).
			// Here we are accessing *s directly.

			// Let's implement it directly here to avoid hacky adaptations.
			elemType := s.Type.Elem()
			buf.WriteString("	if len(*s) > 0 {\n")
			buf.WriteString(fmt.Sprintf("		slice := make([]*ir.Node, len(*s))\n"))
			buf.WriteString("		for i, v := range *s {\n")

			if depth := getIRNodeDepth(elemType); depth > 0 {
				// Slice of *ir.Node (or deeper)
				derefs := ""
				for j := 0; j < depth-1; j++ {
					derefs += "*"
				}
				buf.WriteString(fmt.Sprintf("			slice[i] = %sv\n", derefs))
			} else if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) || (elemType.Name() != "" && elemType.Kind() != reflect.String && !isPrimitiveKind(elemType.Kind())) || elemType.Kind() == reflect.Slice || elemType.Kind() == reflect.Map || elemType.Kind() == reflect.Array {
				// Slice of structs, pointers to structs, or other complex types (named types, nested containers)
				if elemType.Kind() == reflect.Ptr {
					buf.WriteString("			node, err := v.ToTonyIR(opts...)\n")
				} else {
					// v is a value, we need to call ToTonyIR on pointer
					buf.WriteString("			node, err := (&v).ToTonyIR(opts...)\n")
				}
				buf.WriteString("			if err != nil {\n")
				buf.WriteString("				return nil, fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
				buf.WriteString("			}\n")
				buf.WriteString("			slice[i] = node\n")
			} else {
				// Slice of primitives
				elemCode, err := generatePrimitiveToIR("v", elemType)
				if err != nil {
					return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
				}
				buf.WriteString(fmt.Sprintf("			slice[i] = %s\n", elemCode))
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		return ir.FromSlice(slice).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
			buf.WriteString("	}\n")
			buf.WriteString("	return ir.FromSlice(nil).WithTag(\"!\"+s.StructSchema.SchemaName), nil\n")

		case reflect.Map:
			keyType := s.Type.Key()
			valueType := s.Type.Elem()

			if keyType.Kind() == reflect.Uint32 {
				// Sparse array (map[uint32]T)
				buf.WriteString("	if len(*s) > 0 {\n")
				buf.WriteString("		intKeysMap := make(map[uint32]*ir.Node)\n")
				buf.WriteString("		for k, v := range *s {\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString("			node, err := v.ToTonyIR(opts...)\n")
					} else {
						buf.WriteString("			node, err := (&v).ToTonyIR(opts...)\n")
					}
					buf.WriteString("			if err != nil {\n")
					buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			intKeysMap[k] = node\n")
				} else {
					valueCode, err := generatePrimitiveToIR("v", valueType)
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			intKeysMap[k] = %s\n", valueCode))
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		return ir.FromIntKeysMap(intKeysMap).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
				buf.WriteString("	}\n")
				buf.WriteString("	return ir.FromIntKeysMap(nil).WithTag(\"!\"+s.StructSchema.SchemaName), nil\n")

			} else if keyType.Kind() == reflect.String {
				// Regular map (map[string]T)
				buf.WriteString("	if len(*s) > 0 {\n")
				buf.WriteString("		mapNodes := make(map[string]*ir.Node)\n")
				buf.WriteString("		for k, v := range *s {\n")

				if depth := getIRNodeDepth(valueType); depth > 0 {
					// Map value is *ir.Node (or deeper)
					derefs := ""
					for j := 0; j < depth-1; j++ {
						derefs += "*"
					}
					buf.WriteString(fmt.Sprintf("			mapNodes[k] = %sv\n", derefs))
				} else if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString("			node, err := v.ToTonyIR(opts...)\n")
					} else {
						buf.WriteString("			node, err := (&v).ToTonyIR(opts...)\n")
					}
					buf.WriteString("			if err != nil {\n")
					buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			mapNodes[k] = node\n")
				} else {
					valueCode, err := generatePrimitiveToIR("v", valueType)
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			mapNodes[k] = %s\n", valueCode))
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		return ir.FromMap(mapNodes).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
				buf.WriteString("	}\n")
				buf.WriteString("	return ir.FromMap(nil).WithTag(\"!\"+s.StructSchema.SchemaName), nil\n")

			} else if keyType.Kind() == reflect.Interface {
				// Map with interface{} keys
				buf.WriteString("	if len(*s) > 0 {\n")
				buf.WriteString("		mapNodes := make(map[string]*ir.Node)\n")
				buf.WriteString("		for k, v := range *s {\n")
				buf.WriteString("			kStr := fmt.Sprintf(\"%v\", k)\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString("			node, err := v.ToTonyIR(opts...)\n")
					} else {
						buf.WriteString("			node, err := (&v).ToTonyIR(opts...)\n")
					}
					buf.WriteString("			if err != nil {\n")
					buf.WriteString("				return nil, fmt.Errorf(\"failed to convert map value at key %v: %w\", k, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			mapNodes[kStr] = node\n")
				} else {
					valueCode, err := generatePrimitiveToIR("v", valueType)
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			mapNodes[kStr] = %s\n", valueCode))
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		return ir.FromMap(mapNodes).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
				buf.WriteString("	}\n")
				buf.WriteString("	return ir.FromMap(nil).WithTag(\"!\"+s.StructSchema.SchemaName), nil\n")
			} else {
				return "", fmt.Errorf("unsupported map key type for top-level map: %v", keyType.Kind())
			}

		default:
			return "", fmt.Errorf("unsupported basic type for schema generation: %v", s.Type.Kind())
		}
		// buf.WriteString("}\n\n") // Removed because we return directly in cases
		return buf.String(), nil
	}

	// Determine if we need variables
	needsVars := false
	for _, field := range s.Fields {
		if field.Omit {
			continue
		}
		// Complex fields might need error handling or temporary variables
		if field.Type.Kind() == reflect.Struct ||
			(field.Type.Kind() == reflect.Slice && field.Type.Elem().Kind() == reflect.Struct) ||
			(field.Type.Kind() == reflect.Map && field.Type.Elem().Kind() == reflect.Struct) ||
			field.Type.Kind() == reflect.Interface {
			needsVars = true
			break
		}
		// TextMarshaler fields need error handling
		if field.ImplementsTextMarshaler {
			needsVars = true
			break
		}
	}

	if needsVars {
		buf.WriteString("	var node *ir.Node\n")
		buf.WriteString("	var err error\n")
		buf.WriteString("	_ = node // suppress unused variable error\n")
		buf.WriteString("	_ = err  // suppress unused variable error\n\n")
	}

	// Create IR object map
	buf.WriteString("	// Create IR object map\n")
	buf.WriteString("	irMap := make(map[string]*ir.Node)\n\n")

	// Generate code for each field
	for i, field := range s.Fields {
		if field.Omit {
			continue
		}

		// Get schema field name
		schemaFieldName := field.SchemaFieldName
		if schemaFieldName == "" {
			schemaFieldName = field.Name
		}

		// Handle optional fields (skip zero values)
		if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
			buf.WriteString(fmt.Sprintf("	// Field: %s (optional)\n", field.Name))
			if field.Type != nil && field.Type.Kind() == reflect.Ptr {
				buf.WriteString(fmt.Sprintf("	if s.%s != nil {\n", field.Name))
			} else {
				// Non-pointer optional field - check if zero value
				buf.WriteString(fmt.Sprintf("	if !isZeroValue_%s_%s(s.%s) {\n", s.Name, field.Name, field.Name))
			}
		} else {
			buf.WriteString(fmt.Sprintf("	// Field: %s\n", field.Name))
		}

		// Generate code to convert field to IR node
		fieldCode, err := generateFieldToIR(s, field, schemaFieldName, i != 0)
		if err != nil {
			return "", fmt.Errorf("failed to generate field conversion for %q: %w", field.Name, err)
		}
		buf.WriteString(fieldCode)

		if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
			buf.WriteString("	}\n")
		}
		buf.WriteString("\n")
	}

	// Create IR node with schema tag
	buf.WriteString(fmt.Sprintf("	// Create IR node with schema tag\n"))
	buf.WriteString(fmt.Sprintf("	return ir.FromMap(irMap).WithTag(%q), nil\n", "!"+s.StructSchema.SchemaName))
	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateFieldToIR generates code to convert a struct field to an IR node.
func generateFieldToIR(structInfo *StructInfo, field *FieldInfo, schemaFieldName string, redef bool) (string, error) {
	var buf strings.Builder

	// Always use = since node and err are declared at function start
	assign := "="

	if field.Type == nil {
		return "", fmt.Errorf("field %q has no type information", field.Name)
	}

	// Special handling for *ir.Node (and deeper pointers)
	if depth := getIRNodeDepth(field.Type); depth > 0 {
		buf.WriteString(fmt.Sprintf("		if s.%s == nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.Null()\n", schemaFieldName))
		buf.WriteString("		} else {\n")

		// Dereference if depth > 1 (we want *ir.Node)
		derefs := ""
		for i := 0; i < depth-1; i++ {
			derefs += "*"
		}

		buf.WriteString(fmt.Sprintf("			irMap[%q] = %ss.%s\n", schemaFieldName, derefs, field.Name))
		buf.WriteString("		}\n")
		return buf.String(), nil
	}

	// Check for encoding.TextMarshaler using the flag set during type resolution
	// We use the flag instead of runtime reflection because custom types like `type A int`
	// don't preserve methods in reflect.Type
	if field.ImplementsTextMarshaler {
		buf.WriteString(fmt.Sprintf("		if txt, err := s.%s.MarshalText(); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			return nil, fmt.Errorf(\"failed to marshal field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("		} else {\n")
		buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromString(string(txt))\n", schemaFieldName))
		buf.WriteString("		}\n")
		return buf.String(), nil
	}

	// Handle different field types
	switch field.Type.Kind() {
	case reflect.String:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromString(s.%s)\n", schemaFieldName, field.Name))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromInt(int64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		// For unsigned types, we need to handle them carefully
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromInt(int64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromFloat(float64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Bool:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromBool(s.%s)\n", schemaFieldName, field.Name))

	case reflect.Ptr:
		// Pointer type - dereference and recurse
		elemType := field.Type.Elem()
		if elemType.Kind() == reflect.Struct {
			// Nested struct - call ToTony() method
			buf.WriteString(fmt.Sprintf("		if s.%s != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			node, err %s s.%s.ToTonyIR(opts...)\n", assign, field.Name))
			buf.WriteString("			if err != nil {\n")
			buf.WriteString("				return nil, err\n")
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = node\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else {
			// Pointer to primitive - handle based on element type
			fieldCode, err := generateFieldToIR(structInfo, &FieldInfo{
				Name: field.Name,
				Type: elemType,
			}, schemaFieldName, false)
			if err != nil {
				return "", err
			}
			// Wrap in nil check
			buf.WriteString(fmt.Sprintf("		if s.%s != nil {\n", field.Name))
			buf.WriteString(strings.Replace(fieldCode, fmt.Sprintf("s.%s", field.Name), fmt.Sprintf("*s.%s", field.Name), -1))
			buf.WriteString("		}\n")
		}

	case reflect.Slice, reflect.Array:
		// Slice/Array type
		elemType := field.Type.Elem()
		buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			slice := make([]*ir.Node, len(s.%s))\n", field.Name))
		buf.WriteString(fmt.Sprintf("			for i, v := range s.%s {\n", field.Name))
		if depth := getIRNodeDepth(elemType); depth > 0 {
			// Slice of *ir.Node (or deeper) - use directly (with dereference if needed)
			derefs := ""
			for j := 0; j < depth-1; j++ {
				derefs += "*"
			}
			buf.WriteString(fmt.Sprintf("\t\t\t\tslice[i] = %sv\n", derefs))
		} else if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) {
			// Slice of structs or pointers to structs - call ToTony()
			buf.WriteString(fmt.Sprintf("				node, err %s v.ToTonyIR(opts...)\n", assign))
			buf.WriteString("				if err != nil {\n")
			buf.WriteString("					return nil, fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
			buf.WriteString("				}\n")
			buf.WriteString("				slice[i] = node\n")
		} else {
			// Slice of primitives - generate element conversion
			elemCode, err := generatePrimitiveToIR("v", elemType)
			if err != nil {
				return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
			}
			buf.WriteString(fmt.Sprintf("				slice[i] = %s\n", elemCode))
		}
		buf.WriteString("			}\n")
		buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromSlice(slice)\n", schemaFieldName))
		buf.WriteString("		}\n")

	case reflect.Map:
		// Map type
		keyType := field.Type.Key()
		valueType := field.Type.Elem()

		if keyType.Kind() == reflect.Uint32 {
			// Sparse array (map[uint32]T)
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			intKeysMap := make(map[uint32]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				buf.WriteString(fmt.Sprintf("				node, err %s v.ToTonyIR(opts...)\n", assign))
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				intKeysMap[k] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				intKeysMap[k] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromIntKeysMap(intKeysMap)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.String {
			// Regular map (map[string]T)
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			if depth := getIRNodeDepth(valueType); depth > 0 {
				// Map value is *ir.Node (or deeper)
				derefs := ""
				for j := 0; j < depth-1; j++ {
					derefs += "*"
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[k] = %sv\n", derefs))
			} else if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				buf.WriteString(fmt.Sprintf("				node, err %s v.ToTonyIR(opts...)\n", assign))
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				mapNodes[k] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[k] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Interface {
			// Map with interface{} (any) keys - convert keys to strings
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			buf.WriteString("				// Convert interface{} key to string\n")
			buf.WriteString("				kStr := fmt.Sprintf(\"%v\", k)\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				buf.WriteString(fmt.Sprintf("				node, err %s v.ToTonyIR(opts...)\n", assign))
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %v: %w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				mapNodes[kStr] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[kStr] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Ptr {
			// Map with pointer keys - convert pointers to strings
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			buf.WriteString("				// Convert pointer key to string representation\n")
			buf.WriteString("				kStr := fmt.Sprintf(\"%p\", k)\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				buf.WriteString(fmt.Sprintf("				node, err %s v.ToTonyIR(opts...)\n", assign))
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %p: %w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				mapNodes[kStr] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[kStr] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else {
			return "", fmt.Errorf("unsupported map key type: %v (only string, uint32, interface{}, and pointer types are supported)", keyType.Kind())
		}

	case reflect.Interface:
		// Interface{} type - use reflection-based conversion
		// For codegen, we'll use a helper that calls ToIR recursively
		buf.WriteString(fmt.Sprintf("		if s.%s != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			// Interface{} conversion requires runtime reflection\n"))
		buf.WriteString(fmt.Sprintf("			node, err %s toIRInterface(s.%s)\n", assign, field.Name))
		buf.WriteString("			if err != nil {\n")
		buf.WriteString(fmt.Sprintf("				return nil, fmt.Errorf(\"failed to convert field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("			}\n")
		buf.WriteString(fmt.Sprintf("			irMap[%q] = node\n", schemaFieldName))
		buf.WriteString("		}\n")

	case reflect.Struct:
		// Nested struct - call ToTony() method
		buf.WriteString(fmt.Sprintf("		node, err %s s.%s.ToTonyIR(opts...)\n", assign, field.Name))
		buf.WriteString("		if err != nil {\n")
		buf.WriteString(fmt.Sprintf("			return nil, fmt.Errorf(\"failed to convert field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		irMap[%q] = node\n", schemaFieldName))

	default:
		return "", fmt.Errorf("unsupported field type: %v", field.Type.Kind())
	}

	return buf.String(), nil
}

// generatePrimitiveToIR generates code to convert a primitive value to an IR node.
// Returns the code expression (e.g., "ir.FromString(v)").
func generatePrimitiveToIR(varName string, typ reflect.Type) (string, error) {
	switch typ.Kind() {
	case reflect.String:
		return fmt.Sprintf("ir.FromString(%s)", varName), nil
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return fmt.Sprintf("ir.FromInt(int64(%s))", varName), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("ir.FromInt(int64(%s))", varName), nil
	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("ir.FromFloat64(float64(%s))", varName), nil
	case reflect.Bool:
		return fmt.Sprintf("ir.FromBool(%s)", varName), nil
	default:
		return "", fmt.Errorf("unsupported primitive type: %v", typ.Kind())
	}
}

// GenerateFromTonyIRMethod generates the FromTonyIR method for a struct.
func GenerateFromTonyIRMethod(s *StructInfo, sSchema *schema.Schema, currentPkgPath string) (string, error) {
	var buf bytes.Buffer

	// Method signature
	buf.WriteString(fmt.Sprintf("// FromTonyIR populates %s from a Tony IR node.\n", s.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {\n", s.Name))
	buf.WriteString("	if node == nil {\n")
	buf.WriteString("		return nil\n")
	buf.WriteString("	}\n\n")

	// Unwrap CommentType nodes
	buf.WriteString("	// Unwrap CommentType nodes to get the actual data node\n")
	buf.WriteString("	if node.Type == ir.CommentType {\n")

	// Extract Head Comments if configured
	if s.StructSchema != nil && s.StructSchema.CommentFieldName != "" {
		buf.WriteString(fmt.Sprintf("		s.%s = node.Lines\n", s.StructSchema.CommentFieldName))
	}

	buf.WriteString("		if len(node.Values) > 0 {\n")
	buf.WriteString("			node = node.Values[0]\n")
	buf.WriteString("		} else {\n")
	buf.WriteString("			return nil\n")
	buf.WriteString("		}\n")
	buf.WriteString("	}\n\n")

	// Extract Line Comments if configured
	if s.StructSchema != nil && s.StructSchema.LineCommentFieldName != "" {
		buf.WriteString("	if node.Comment != nil {\n")
		buf.WriteString(fmt.Sprintf("		s.%s = node.Comment.Lines\n", s.StructSchema.LineCommentFieldName))
		buf.WriteString("	}\n\n")
	}

	// Check for TextUnmarshaler implementation on the type itself
	if s.ImplementsTextUnmarshaler {
		buf.WriteString("	// Use TextUnmarshaler implementation\n")
		buf.WriteString("	if node.Type != ir.StringType {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected string for %s, got %%v\", node.Type)\n", s.Name))
		buf.WriteString("	}\n")
		buf.WriteString("	if err := s.UnmarshalText([]byte(node.String)); err != nil {\n")
		buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"failed to unmarshal %s: %%w\", err)\n", s.Name))
		buf.WriteString("	}\n")
		buf.WriteString("	return nil\n")
		buf.WriteString("}\n\n")
		return buf.String(), nil
	}

	// Handle basic types (non-structs)
	if s.Type != nil && s.Type.Kind() != reflect.Struct {
		// Basic type conversion
		switch s.Type.Kind() {
		case reflect.String:
			buf.WriteString("	if node.Type != ir.StringType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected string for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.String)\n", s.Name))
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			buf.WriteString("	if node.Type != ir.IntType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected int for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Int)\n", s.Name))
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			buf.WriteString("	if node.Type != ir.IntType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected int for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Int)\n", s.Name))
		case reflect.Float32, reflect.Float64:
			buf.WriteString("	if node.Type != ir.FloatType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected float for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Float)\n", s.Name))
		case reflect.Bool:
			buf.WriteString("	if node.Type != ir.BoolType {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected bool for %s, got %%v\", node.Type)\n", s.Name))
			buf.WriteString("	}\n")
			buf.WriteString(fmt.Sprintf("	*s = %s(node.Bool)\n", s.Name))

		// Handle container types (Slice, Array, Map)
		case reflect.Slice, reflect.Array:
			elemType := s.Type.Elem()
			buf.WriteString("	if node.Type == ir.ArrayType {\n")

			// Use qualified type name for the slice element type
			structName := getQualifiedTypeName(elemType, currentPkgPath)

			buf.WriteString(fmt.Sprintf("		slice := make([]%s, len(node.Values))\n", structName))
			buf.WriteString("		for i, v := range node.Values {\n")

			if depth := getIRNodeDepth(elemType); depth > 0 {
				// Slice of *ir.Node (or deeper)
				if depth == 1 {
					buf.WriteString("			slice[i] = v\n")
				} else {
					// Chain of pointers
					buf.WriteString("			v0 := v\n")
					for j := 1; j < depth; j++ {
						buf.WriteString(fmt.Sprintf("			v%d := &v%d\n", j, j-1))
					}
					buf.WriteString(fmt.Sprintf("			slice[i] = v%d\n", depth-1))
				}
			} else if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) || (elemType.Name() != "" && elemType.Kind() != reflect.String && !isPrimitiveKind(elemType.Kind())) || elemType.Kind() == reflect.Slice || elemType.Kind() == reflect.Map || elemType.Kind() == reflect.Array {
				// Slice of structs, pointers to structs, or other complex types
				if elemType.Kind() == reflect.Ptr {
					// Element is already a pointer, allocate new instance
					elemStructName := getQualifiedTypeName(elemType.Elem(), currentPkgPath)
					buf.WriteString(fmt.Sprintf("			elem := new(%s)\n", elemStructName))
					buf.WriteString("			if err := elem.FromTonyIR(v, opts...); err != nil {\n")
					buf.WriteString("				return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			slice[i] = elem\n")
				} else {
					// Element is a struct value
					buf.WriteString(fmt.Sprintf("			elem := %s{}\n", structName))
					buf.WriteString("			if err := elem.FromTonyIR(v, opts...); err != nil {\n")
					buf.WriteString("				return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
					buf.WriteString("			}\n")
					buf.WriteString("			slice[i] = elem\n")
				}
			} else {
				// Slice of primitives
				buf.WriteString("			ctx := fmt.Sprintf(\"slice element %d\", i)\n")
				elemCode, err := generatePrimitiveFromIR("v", elemType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
				}
				buf.WriteString(fmt.Sprintf("			var elem %s\n", getQualifiedTypeName(elemType, currentPkgPath)))
				buf.WriteString(fmt.Sprintf("			%s\n", elemCode))
				buf.WriteString("			slice[i] = elem\n")
			}
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		*s = %s(slice)\n", s.Name))
			buf.WriteString("	}\n")

		case reflect.Map:
			keyType := s.Type.Key()
			valueType := s.Type.Elem()

			if keyType.Kind() == reflect.Uint32 {
				// Sparse array (map[uint32]T)
				buf.WriteString("	if node.Type == ir.ObjectType && node.Tag == \"!sparsearray\" {\n")
				structName := getQualifiedTypeName(valueType, currentPkgPath)
				buf.WriteString(fmt.Sprintf("		m := make(map[uint32]%s)\n", structName))
				buf.WriteString("		irMap := ir.ToMap(node)\n")
				buf.WriteString("		for kStr, v := range irMap {\n")
				buf.WriteString("			k, err := strconv.ParseUint(kStr, 10, 32)\n")
				buf.WriteString("			if err != nil {\n")
				buf.WriteString("				return fmt.Errorf(\"invalid sparse array key %q: %w\", kStr, err)\n")
				buf.WriteString("			}\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			val := new(%s)\n", getQualifiedTypeName(valueType.Elem(), currentPkgPath)))
						buf.WriteString("			if err := val.FromTonyIR(v, opts...); err != nil {\n")
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[uint32(k)] = val\n")
					} else {
						buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
						buf.WriteString("			if err := val.FromTonyIR(v, opts...); err != nil {\n")
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[uint32(k)] = val\n")
					}
				} else {
					buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %d\", k)\n")
					valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
					buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
					buf.WriteString("			m[uint32(k)] = val\n")
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*s = %s(m)\n", s.Name))
				buf.WriteString("	}\n")

			} else if keyType.Kind() == reflect.String {
				// Regular map (map[string]T)
				buf.WriteString("	if node.Type == ir.ObjectType {\n")
				structName := getQualifiedTypeName(valueType, currentPkgPath)
				if depth := getIRNodeDepth(valueType); depth > 0 {
					structName = "*ir.Node"
				}
				buf.WriteString(fmt.Sprintf("		m := make(map[string]%s)\n", structName))
				buf.WriteString("		irMap := ir.ToMap(node)\n")
				buf.WriteString("		for k, v := range irMap {\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			val := new(%s)\n", getQualifiedTypeName(valueType.Elem(), currentPkgPath)))
						buf.WriteString("			if err := val.FromTonyIR(v, opts...); err != nil {\n")
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					} else {
						buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
						buf.WriteString("			if err := val.FromTonyIR(v, opts...); err != nil {\n")
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					}
				} else if depth := getIRNodeDepth(valueType); depth > 0 {
					if depth == 1 {
						buf.WriteString("			m[k] = v\n")
					} else {
						buf.WriteString("			v0 := v\n")
						for j := 1; j < depth; j++ {
							buf.WriteString(fmt.Sprintf("			v%d := &v%d\n", j, j-1))
						}
						buf.WriteString(fmt.Sprintf("			m[k] = v%d\n", depth-1))
					}
				} else {
					buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %q\", k)\n")
					valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
					buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
					buf.WriteString("			m[k] = val\n")
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*s = %s(m)\n", s.Name))
				buf.WriteString("	}\n")

			} else if keyType.Kind() == reflect.Interface {
				// Map with interface{} keys
				buf.WriteString("	if node.Type == ir.ObjectType {\n")
				structName := getQualifiedTypeName(valueType, currentPkgPath)
				buf.WriteString(fmt.Sprintf("		m := make(map[interface{}]%s)\n", structName))
				buf.WriteString("		irMap := ir.ToMap(node)\n")
				buf.WriteString("		for kStr, v := range irMap {\n")
				buf.WriteString("			var k interface{} = kStr\n")

				if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) || (valueType.Name() != "" && valueType.Kind() != reflect.String && !isPrimitiveKind(valueType.Kind())) || valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Map || valueType.Kind() == reflect.Array {
					if valueType.Kind() == reflect.Ptr {
						buf.WriteString(fmt.Sprintf("			val := new(%s)\n", getQualifiedTypeName(valueType.Elem(), currentPkgPath)))
						buf.WriteString("			if err := val.FromTonyIR(v, opts...); err != nil {\n")
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %v: %%w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					} else {
						buf.WriteString(fmt.Sprintf("			val := %s{}\n", structName))
						buf.WriteString("			if err := val.FromTonyIR(v, opts...); err != nil {\n")
						buf.WriteString("				return fmt.Errorf(\"failed to convert map value at key %v: %%w\", k, err)\n")
						buf.WriteString("			}\n")
						buf.WriteString("			m[k] = val\n")
					}
				} else {
					buf.WriteString("			ctx := fmt.Sprintf(\"map value at key %v\", k)\n")
					valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
					if err != nil {
						return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
					}
					buf.WriteString(fmt.Sprintf("			var val %s\n", getQualifiedTypeName(valueType, currentPkgPath)))
					buf.WriteString(fmt.Sprintf("			%s\n", valueCode))
					buf.WriteString("			m[k] = val\n")
				}
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*s = %s(m)\n", s.Name))
				buf.WriteString("	}\n")
			} else {
				return "", fmt.Errorf("unsupported map key type for top-level map: %v", keyType.Kind())
			}

		default:
			return "", fmt.Errorf("unsupported basic type for schema generation: %v", s.Type.Kind())
		}
		buf.WriteString("	return nil\n")
		buf.WriteString("}\n\n")
		return buf.String(), nil
	}

	buf.WriteString("	if node.Type == ir.NullType {\n")
	buf.WriteString("		return nil\n")
	buf.WriteString("	}\n")
	buf.WriteString("	if node.Type != ir.ObjectType {\n")
	buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"expected map for %s, got %%v\", node.Type)\n", s.Name))
	buf.WriteString("	}\n\n")

	// Track required fields
	for _, field := range s.Fields {
		if field.Required && !field.Omit {
			buf.WriteString(fmt.Sprintf("	var found_%s bool\n", field.Name))
		}
	}

	buf.WriteString("	for i, fieldName := range node.Fields {\n")
	buf.WriteString("		fieldNode := node.Values[i]\n")
	buf.WriteString("		switch fieldName.String {\n")

	// Get struct fields from schema using GetStructFields
	// For now, we'll iterate over StructInfo.Fields
	for _, field := range s.Fields {
		if field.Omit {
			continue
		}

		// Get schema field name
		schemaFieldName := field.SchemaFieldName
		if schemaFieldName == "" {
			schemaFieldName = field.Name
		}

		buf.WriteString(fmt.Sprintf("		case %q:\n", schemaFieldName))

		// Generate code to decode field
		fieldCode, err := generateFieldDecoding(s, field, schemaFieldName)
		if err != nil {
			return "", fmt.Errorf("failed to generate field decoding for %q: %w", field.Name, err)
		}
		buf.WriteString(fieldCode)

		if field.Required {
			buf.WriteString(fmt.Sprintf("			found_%s = true\n", field.Name))
		}
	}

	buf.WriteString("		}\n")
	buf.WriteString("	}\n\n")

	// Check required fields
	for _, field := range s.Fields {
		if field.Required && !field.Omit {
			schemaFieldName := field.SchemaFieldName
			if schemaFieldName == "" {
				schemaFieldName = field.Name
			}

			buf.WriteString(fmt.Sprintf("	if !found_%s {\n", field.Name))
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"required field %%q is missing\", %q)\n", schemaFieldName))
			buf.WriteString("	}\n")
		}
	}

	// Handle allowExtra flag
	if s.StructSchema != nil && s.StructSchema.AllowExtra {
		buf.WriteString("	// allowExtra is true, so extra fields are ignored\n")
	} else {
		// Validate no extra fields (optional - can be added later)
	}

	buf.WriteString("	return nil\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// GenerateToTonyMethod generates a ToTony() method for a struct.
func GenerateToTonyMethod(structInfo *StructInfo) (string, error) {
	var buf strings.Builder

	// Method signature
	buf.WriteString(fmt.Sprintf("// ToTony converts %s to Tony format bytes.\n", structInfo.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) ToTony(opts ...gomap.MapOption) ([]byte, error) {\n", structInfo.Name))
	buf.WriteString("	node, err := s.ToTonyIR(opts...)\n")
	buf.WriteString("	if err != nil {\n")
	buf.WriteString("		return nil, err\n")
	buf.WriteString("	}\n")
	buf.WriteString("	var buf bytes.Buffer\n")
	buf.WriteString("	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {\n")
	buf.WriteString("		return nil, err\n")
	buf.WriteString("	}\n")
	buf.WriteString("	return buf.Bytes(), nil\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// GenerateFromTonyMethod generates a FromTony() method for a struct.
func GenerateFromTonyMethod(structInfo *StructInfo) (string, error) {
	var buf strings.Builder

	// Method signature
	buf.WriteString(fmt.Sprintf("// FromTony parses Tony format bytes and populates %s.\n", structInfo.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) FromTony(data []byte, opts ...gomap.UnmapOption) error {\n", structInfo.Name))
	buf.WriteString("	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)\n")
	buf.WriteString("	if err != nil {\n")
	buf.WriteString("		return err\n")
	buf.WriteString("	}\n")
	buf.WriteString("	return s.FromTonyIR(node, opts...)\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// getTypeName returns the type name for code generation.
// Uses StructTypeName if available (for struct types), otherwise uses Type.Name().
func getTypeName(typ reflect.Type, structTypeName string) string {
	if structTypeName != "" {
		return structTypeName
	}
	return typ.Name()
}

// getQualifiedTypeName returns the qualified type name for code generation.
// It handles cross-package references by using the package name.
func getQualifiedTypeName(typ reflect.Type, currentPkg string) string {
	if typ == nil {
		return ""
	}

	// Named types - Check this FIRST to avoid infinite recursion for recursive types
	if typ.Name() != "" {
		if typ.PkgPath() != "" && typ.PkgPath() != currentPkg {
			// External package
			// We need the package name, which is the last part of the path
			// This is a heuristic; ideally we'd have a map of path -> name
			parts := strings.Split(typ.PkgPath(), "/")
			pkgName := parts[len(parts)-1]
			return pkgName + "." + typ.Name()
		}
		return typ.Name()
	}

	// Handle pointers
	if typ.Kind() == reflect.Ptr {
		return "*" + getQualifiedTypeName(typ.Elem(), currentPkg)
	}

	// Handle slices
	if typ.Kind() == reflect.Slice {
		return "[]" + getQualifiedTypeName(typ.Elem(), currentPkg)
	}

	// Handle arrays
	if typ.Kind() == reflect.Array {
		return fmt.Sprintf("[%d]%s", typ.Len(), getQualifiedTypeName(typ.Elem(), currentPkg))
	}

	// Handle maps
	if typ.Kind() == reflect.Map {
		return fmt.Sprintf("map[%s]%s", getQualifiedTypeName(typ.Key(), currentPkg), getQualifiedTypeName(typ.Elem(), currentPkg))
	}

	// Basic types
	return typ.Kind().String()
}

// generateFieldDecoding generates code to decode a field from an IR node.
func generateFieldDecoding(structInfo *StructInfo, field *FieldInfo, schemaFieldName string) (string, error) {
	var buf strings.Builder

	// Special handling for *ir.Node (and deeper pointers)
	if depth := getIRNodeDepth(field.Type); depth > 0 {
		if depth == 1 {
			// *ir.Node - direct assignment
			buf.WriteString(fmt.Sprintf("		s.%s = fieldNode\n", field.Name))
		} else {
			// Create chain of pointers
			// We need to create a chain of pointers: s.Field -> ptr(N-1) -> ... -> ptr0 -> fieldNode
			// v0 := fieldNode
			// v1 := &v0
			// ...
			// s.Field = v(depth-1)

			buf.WriteString("			v0 := fieldNode\n")
			for i := 1; i < depth; i++ {
				buf.WriteString(fmt.Sprintf("			v%d := &v%d\n", i, i-1))
			}
			buf.WriteString(fmt.Sprintf("			s.%s = v%d\n", field.Name, depth-1))
		}
		return buf.String(), nil
	}

	// Check for encoding.TextUnmarshaler using the flag set during type resolution
	// We use the flag instead of runtime reflection because custom types like `type A int`
	// don't preserve methods in reflect.Type
	if field.ImplementsTextUnmarshaler {
		if field.Type.Kind() != reflect.Ptr {
			// Value type implementing TextUnmarshaler (via pointer receiver)
			buf.WriteString("		if fieldNode.Type != ir.StringType {\n")
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected string for TextUnmarshaler, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
			buf.WriteString("		}\n")
			buf.WriteString(fmt.Sprintf("		if err := s.%s.UnmarshalText([]byte(fieldNode.String)); err != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: failed to unmarshal text: %%w\", %q, err)\n", schemaFieldName))
			buf.WriteString("		}\n")
			return buf.String(), nil
		} else {
			// Pointer type implementing TextUnmarshaler
			buf.WriteString("		if fieldNode.Type == ir.NullType {\n")
			buf.WriteString(fmt.Sprintf("			s.%s = nil\n", field.Name))
			buf.WriteString("		} else if fieldNode.Type != ir.StringType {\n")
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected string for TextUnmarshaler, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
			buf.WriteString("		} else {\n")
			buf.WriteString(fmt.Sprintf("			if s.%s == nil {\n", field.Name))
			// Use getTypeName to handle imported types correctly
			typeName := getTypeName(field.Type.Elem(), field.StructTypeName)
			buf.WriteString(fmt.Sprintf("				s.%s = new(%s)\n", field.Name, typeName))
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			if err := s.%s.UnmarshalText([]byte(fieldNode.String)); err != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("				return fmt.Errorf(\"field %%q: failed to unmarshal text: %%w\", %q, err)\n", schemaFieldName))
			buf.WriteString("			}\n")
			buf.WriteString("		}\n")
			return buf.String(), nil
		}
	}

	// Field comment
	buf.WriteString(fmt.Sprintf("		// Field: %s\n", field.Name))

	// Handle different field types
	switch field.Type.Kind() {
	case reflect.String:
		buf.WriteString("		if fieldNode.Type != ir.StringType {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected string, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = fieldNode.String\n", field.Name))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString("		if fieldNode.Int64 == nil {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		// Handle overflow checking for smaller int types
		intVal := "*fieldNode.Int64"
		if field.Type.Kind() == reflect.Int8 {
			buf.WriteString(fmt.Sprintf("		if %s < -128 || %s > 127 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows int8\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Int16 {
			buf.WriteString(fmt.Sprintf("		if %s < -32768 || %s > 32767 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows int16\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Int32 {
			buf.WriteString(fmt.Sprintf("		if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows int32\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		}
		buf.WriteString(fmt.Sprintf("		s.%s = %s(%s)\n", field.Name, field.Type.Name(), intVal))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString("		if fieldNode.Int64 == nil {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		// Check for negative values and overflow
		intVal := "*fieldNode.Int64"
		buf.WriteString(fmt.Sprintf("		if %s < 0 {\n", intVal))
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: negative value %%d for unsigned type\", %q, %s)\n", schemaFieldName, intVal))
		buf.WriteString("		}\n")
		if field.Type.Kind() == reflect.Uint8 {
			buf.WriteString(fmt.Sprintf("		if %s > 255 {\n", intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows uint8\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Uint16 {
			buf.WriteString(fmt.Sprintf("		if %s > 65535 {\n", intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows uint16\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Uint32 {
			buf.WriteString(fmt.Sprintf("		if %s > 4294967295 {\n", intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows uint32\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		}
		buf.WriteString(fmt.Sprintf("		s.%s = %s(%s)\n", field.Name, field.Type.Name(), intVal))

	case reflect.Float32, reflect.Float64:
		buf.WriteString("		if fieldNode.Float64 == nil {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = %s(*fieldNode.Float64)\n", field.Name, field.Type.Name()))

	case reflect.Bool:
		buf.WriteString("		if fieldNode.Type != ir.BoolType {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected bool, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = fieldNode.Bool\n", field.Name))

	case reflect.Ptr:
		// Pointer type
		elemType := field.Type.Elem()
		if elemType.Kind() == reflect.Struct {
			// Pointer to struct - call FromTony()
			structName := getTypeName(elemType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("		s.%s = &%s{}\n", field.Name, structName))
			buf.WriteString(fmt.Sprintf("		if err := s.%s.FromTonyIR(fieldNode, opts...); err != nil {\n", field.Name))
			buf.WriteString("			return err\n")
			buf.WriteString("		}\n")
		} else {
			// Pointer to primitive (or named basic type like format.Format)
			typeName := getTypeName(elemType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("		val := new(%s)\n", typeName))

			// Generate validation and extraction based on underlying type
			switch elemType.Kind() {
			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
				buf.WriteString("		if fieldNode.Int64 == nil {\n")
				buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: expected number, got %%v\", %q, fieldNode.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("		}\n")
				// Handle overflow checking for smaller int types
				intVal := "*fieldNode.Int64"
				if elemType.Kind() == reflect.Int8 {
					buf.WriteString(fmt.Sprintf("		if %s < -128 || %s > 127 {\n", intVal, intVal))
					buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: value %%d overflows int8\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("		}\n")
				} else if elemType.Kind() == reflect.Int16 {
					buf.WriteString(fmt.Sprintf("		if %s < -32768 || %s > 32767 {\n", intVal, intVal))
					buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: value %%d overflows int16\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("		}\n")
				} else if elemType.Kind() == reflect.Int32 {
					buf.WriteString(fmt.Sprintf("		if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
					buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: value %%d overflows int32\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("		}\n")
				}
				buf.WriteString(fmt.Sprintf("		*val = %s(%s)\n", typeName, intVal))
			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
				buf.WriteString("		if fieldNode.Int64 == nil {\n")
				buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: expected number, got %%v\", %q, fieldNode.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("		}\n")
				// Check for negative values and overflow
				intVal := "*fieldNode.Int64"
				buf.WriteString(fmt.Sprintf("		if %s < 0 {\n", intVal))
				buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: negative value %%d for unsigned type\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
				buf.WriteString("		}\n")
				if elemType.Kind() == reflect.Uint8 {
					buf.WriteString(fmt.Sprintf("		if %s > 255 {\n", intVal))
					buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: value %%d overflows uint8\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("		}\n")
				} else if elemType.Kind() == reflect.Uint16 {
					buf.WriteString(fmt.Sprintf("		if %s > 65535 {\n", intVal))
					buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: value %%d overflows uint16\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("		}\n")
				} else if elemType.Kind() == reflect.Uint32 {
					buf.WriteString(fmt.Sprintf("		if %s > 4294967295 {\n", intVal))
					buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: value %%d overflows uint32\", %q, %s)\n", fmt.Sprintf("field %q", schemaFieldName), intVal))
					buf.WriteString("		}\n")
				}
				buf.WriteString(fmt.Sprintf("		*val = %s(%s)\n", typeName, intVal))
			case reflect.Float32, reflect.Float64:
				buf.WriteString("		if fieldNode.Float64 == nil {\n")
				buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: expected number, got %%v\", %q, fieldNode.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*val = %s(*fieldNode.Float64)\n", typeName))
			case reflect.String:
				buf.WriteString("		if fieldNode.Type != ir.StringType {\n")
				buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: expected string, got %%v\", %q, fieldNode.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*val = %s(fieldNode.String)\n", typeName))
			case reflect.Bool:
				buf.WriteString("		if fieldNode.Type != ir.BoolType {\n")
				buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"%%s: expected bool, got %%v\", %q, fieldNode.Type)\n", fmt.Sprintf("field %q", schemaFieldName)))
				buf.WriteString("		}\n")
				buf.WriteString(fmt.Sprintf("		*val = %s(fieldNode.Bool)\n", typeName))
			default:
				return "", fmt.Errorf("unsupported pointer to primitive type: %v", elemType.Kind())
			}

			buf.WriteString(fmt.Sprintf("		s.%s = val\n", field.Name))
		}

	case reflect.Slice, reflect.Array:
		// Slice/Array type
		elemType := field.Type.Elem()
		buf.WriteString("		if fieldNode.Type == ir.ArrayType {\n")
		structName := getTypeName(elemType, field.StructTypeName)
		buf.WriteString(fmt.Sprintf("			slice := make([]%s, len(fieldNode.Values))\n", structName))
		buf.WriteString("			for i, v := range fieldNode.Values {\n")
		if elemType.Kind() == reflect.Struct || (elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Struct) {
			// Slice of structs or pointers to structs - call FromTony()
			// Need to handle both struct values and pointers
			if elemType.Kind() == reflect.Ptr {
				// Element is already a pointer, allocate new instance
				buf.WriteString(fmt.Sprintf("				elem := new(%s)\n", getTypeName(elemType.Elem(), field.StructTypeName)))
				buf.WriteString("				if err := elem.FromTonyIR(v, opts...); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				slice[i] = elem\n")
			} else {
				// Element is a struct value
				buf.WriteString(fmt.Sprintf("				elem := %s{}\n", structName))
				buf.WriteString("				if err := elem.FromTonyIR(v, opts...); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"failed to convert slice element %d: %w\", i, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				slice[i] = elem\n")
			}
		} else {
			// Slice of primitives
			// Generate code with a context variable that will be formatted
			buf.WriteString("				ctx := fmt.Sprintf(\"slice element %d\", i)\n")
			elemCode, err := generatePrimitiveFromIR("v", elemType, "ctx")
			if err != nil {
				return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
			}
			buf.WriteString(fmt.Sprintf("				var elem %s\n", getTypeName(elemType, "")))
			buf.WriteString(fmt.Sprintf("				%s\n", elemCode))
			buf.WriteString("				slice[i] = elem\n")
		}
		buf.WriteString("			}\n")
		buf.WriteString(fmt.Sprintf("			s.%s = slice\n", field.Name))
		buf.WriteString("		}\n")

	case reflect.Map:
		// Map type
		keyType := field.Type.Key()
		valueType := field.Type.Elem()

		if keyType.Kind() == reflect.Uint32 {
			// Sparse array (map[uint32]T)
			buf.WriteString("		if fieldNode.Type == ir.ObjectType && fieldNode.Tag == \"!sparsearray\" {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("			m := make(map[uint32]%s)\n", structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for kStr, v := range irMap {\n")
			buf.WriteString("				k, err := strconv.ParseUint(kStr, 10, 32)\n")
			buf.WriteString("				if err != nil {\n")
			buf.WriteString("					return fmt.Errorf(\"invalid sparse array key %q: %w\", kStr, err)\n")
			buf.WriteString("				}\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				// Map value is struct or pointer to struct
				if valueType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("				val := new(%s)\n", getTypeName(valueType.Elem(), field.StructTypeName)))
					buf.WriteString("				if err := val.FromTonyIR(v, opts...); err != nil {\n")
					buf.WriteString("					return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
					buf.WriteString("				}\n")
					buf.WriteString("				m[uint32(k)] = val\n")
				} else {
					buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
					buf.WriteString("				if err := val.FromTonyIR(v, opts...); err != nil {\n")
					buf.WriteString("					return fmt.Errorf(\"failed to convert map value at key %d: %w\", k, err)\n")
					buf.WriteString("				}\n")
					buf.WriteString("				m[uint32(k)] = val\n")
				}
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %d\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[uint32(k)] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.String {
			// Regular map (map[string]T)
			buf.WriteString("		if fieldNode.Type == ir.ObjectType {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			if depth := getIRNodeDepth(valueType); depth > 0 {
				structName = "*ir.Node"
			}
			buf.WriteString(fmt.Sprintf("			m := make(map[string]%s)\n", structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for k, v := range irMap {\n")
			if valueType.Kind() == reflect.Struct || (valueType.Kind() == reflect.Ptr && valueType.Elem().Kind() == reflect.Struct) {
				// Map value is struct or pointer to struct
				if valueType.Kind() == reflect.Ptr {
					buf.WriteString(fmt.Sprintf("				val := new(%s)\n", getTypeName(valueType.Elem(), field.StructTypeName)))
					buf.WriteString("				if err := val.FromTonyIR(v, opts...); err != nil {\n")
					buf.WriteString("					return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
					buf.WriteString("				}\n")
					buf.WriteString("				m[k] = val\n")
				} else {
					buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
					buf.WriteString("				if err := val.FromTonyIR(v, opts...); err != nil {\n")
					buf.WriteString("					return fmt.Errorf(\"failed to convert map value at key %q: %w\", k, err)\n")
					buf.WriteString("				}\n")
					buf.WriteString("				m[k] = val\n")
				}
			} else if depth := getIRNodeDepth(valueType); depth > 0 {
				if depth == 1 {
					buf.WriteString("				m[k] = v\n")
				} else {
					// We need to create a chain of pointers
					buf.WriteString("				v0 := v\n")
					for j := 1; j < depth; j++ {
						buf.WriteString(fmt.Sprintf("				v%d := &v%d\n", j, j-1))
					}
					buf.WriteString(fmt.Sprintf("				m[k] = v%d\n", depth-1))
				}
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %q\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[k] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Interface {
			// Map with interface{} (any) keys - keys were converted to strings
			buf.WriteString("		if fieldNode.Type == ir.ObjectType {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("			m := make(map[interface{}]%s)\n", structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for kStr, v := range irMap {\n")
			buf.WriteString("				// Convert string key back to interface{}\n")
			buf.WriteString("				var k interface{} = kStr\n")
			if valueType.Kind() == reflect.Struct {
				buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
				buf.WriteString("				if err := val.FromTonyIR(v); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"map value at key %v: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				m[k] = val\n")
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %v\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[k] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Ptr {
			// Map with pointer keys - keys were converted to strings (pointer addresses)
			// Note: We can't reconstruct the original pointer from the address string,
			// so this is a lossy conversion. The pointer address is preserved as a string.
			buf.WriteString("		// Note: Pointer keys cannot be fully reconstructed from serialized form\n")
			buf.WriteString("		// Pointer addresses are preserved as strings, but original pointers are lost\n")
			buf.WriteString("		if fieldNode.Type == ir.ObjectType {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			elemType := keyType.Elem()
			// Extract key struct name from AST if available (for pointer keys like *X)
			keyStructNameFromAST := ""
			if field.ASTType != nil {
				if mapType, ok := field.ASTType.(*ast.MapType); ok {
					if keyIdent, ok := mapType.Key.(*ast.StarExpr); ok {
						if ident, ok := keyIdent.X.(*ast.Ident); ok {
							keyStructNameFromAST = ident.Name
						}
					}
				}
			}
			// Use AST name if available, otherwise try type name, fallback to interface{}
			keyStructName := keyStructNameFromAST
			if keyStructName == "" {
				keyStructName = elemType.Name()
			}
			if keyStructName == "" {
				keyStructName = "interface{}"
			}
			buf.WriteString(fmt.Sprintf("			m := make(map[*%s]%s)\n", keyStructName, structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for kStr, v := range irMap {\n")
			buf.WriteString("				// Parse pointer address from string (format: 0x...)\n")
			buf.WriteString("				var ptrAddr uintptr\n")
			buf.WriteString("				if _, err := fmt.Sscanf(kStr, \"0x%%x\", &ptrAddr); err != nil {\n")
			buf.WriteString("					return fmt.Errorf(\"invalid pointer address format %%q: %%w\", kStr, err)\n")
			buf.WriteString("				}\n")
			buf.WriteString(fmt.Sprintf("				k := (*%s)(unsafe.Pointer(ptrAddr))\n", keyStructName))
			if valueType.Kind() == reflect.Struct {
				buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
				buf.WriteString("				if err := val.FromTonyIR(v); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"map value at key %p: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				m[k] = val\n")
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %p\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[k] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else {
			return "", fmt.Errorf("unsupported map key type: %v (only string, uint32, interface{}, and pointer types are supported)", keyType.Kind())
		}

	case reflect.Interface:
		// Interface{} type - use reflection-based conversion
		buf.WriteString(fmt.Sprintf("		// Interface{} conversion requires runtime reflection\n"))
		buf.WriteString(fmt.Sprintf("		if err := fromIRInterface(fieldNode, &s.%s); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: %%w\", %q, err)\n", schemaFieldName))
		buf.WriteString("		}\n")

	case reflect.Struct:
		// Nested struct - call FromTony()
		buf.WriteString(fmt.Sprintf("		if err := s.%s.FromTonyIR(fieldNode); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: %%w\", %q, err)\n", schemaFieldName))
		buf.WriteString("		}\n")

	default:
		return "", fmt.Errorf("unsupported field type: %v", field.Type.Kind())
	}

	return buf.String(), nil
}

// generatePrimitiveFromIR generates code to extract a primitive value from an IR node.
// Returns the code statement (e.g., "if v.Type != ir.StringType { return fmt.Errorf(...) }; elem = v.String").
// The context parameter can contain format specifiers like %d, %q, etc. that will be used in error messages.
func generatePrimitiveFromIR(varName string, typ reflect.Type, context string) (string, error) {
	var buf strings.Builder

	switch typ.Kind() {
	case reflect.String:
		buf.WriteString(fmt.Sprintf("if %s.Type != ir.StringType {\n", varName))
		// Use %q to properly quote the context string in the error message
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected string, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s.String", varName))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString(fmt.Sprintf("if %s.Int64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		intVal := fmt.Sprintf("*%s.Int64", varName)
		// Overflow checking
		if typ.Kind() == reflect.Int8 {
			buf.WriteString(fmt.Sprintf("if %s < -128 || %s > 127 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int8\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Int16 {
			buf.WriteString(fmt.Sprintf("if %s < -32768 || %s > 32767 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int16\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Int32 {
			buf.WriteString(fmt.Sprintf("if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int32\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		}
		buf.WriteString(fmt.Sprintf("elem = %s(%s)", typ.Name(), intVal))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString(fmt.Sprintf("if %s.Int64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		intVal := fmt.Sprintf("*%s.Int64", varName)
		buf.WriteString(fmt.Sprintf("if %s < 0 {\n", intVal))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: negative value %%d for unsigned type\", %s, %s)\n", context, intVal))
		buf.WriteString("}\n")
		if typ.Kind() == reflect.Uint8 {
			buf.WriteString(fmt.Sprintf("if %s > 255 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint8\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Uint16 {
			buf.WriteString(fmt.Sprintf("if %s > 65535 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint16\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Uint32 {
			buf.WriteString(fmt.Sprintf("if %s > 4294967295 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint32\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		}
		buf.WriteString(fmt.Sprintf("elem = %s(%s)", typ.Name(), intVal))

	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("if %s.Float64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s(*%s.Float64)", typ.Name(), varName))

	case reflect.Bool:
		buf.WriteString(fmt.Sprintf("if %s.Type != ir.BoolType {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected bool, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s.Bool", varName))

	default:
		return "", fmt.Errorf("unsupported primitive type: %v", typ.Kind())
	}

	return buf.String(), nil
}

// isPrimitiveKind checks if a kind is a primitive type (bool, int*, uint*, float*, string)
func isPrimitiveKind(k reflect.Kind) bool {
	switch k {
	case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64, reflect.String:
		return true
	default:
		return false
	}
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// Helper function to extract assignment from generated code
func extractAssignment(code string) string {
	lines := strings.Split(code, "\n")
	for _, line := range lines {
		if strings.Contains(line, "=") && !strings.Contains(line, "if") && !strings.Contains(line, "return") {
			return strings.TrimSpace(line)
		}
	}
	return ""
}

// HasToTonyMethod checks if a type has a ToTony() method.
func HasToTonyMethod(typ reflect.Type) bool {
	method, ok := typ.MethodByName("ToTony")
	if !ok {
		// Check pointer receiver
		if typ.Kind() != reflect.Ptr {
			ptrType := reflect.PtrTo(typ)
			_, ok = ptrType.MethodByName("ToTony")
		}
		return ok
	}

	// Verify signature: ToTony() (*ir.Node, error)
	if method.Type.NumIn() != 1 || method.Type.NumOut() != 2 {
		return false
	}

	// Check return types
	out0 := method.Type.Out(0)
	out1 := method.Type.Out(1)

	// out0 should be *ir.Node, out1 should be error
	return out0.Kind() == reflect.Ptr && out1.Name() == "error"
}

// HasFromTonyMethod checks if a type has a FromTony() method.
func HasFromTonyMethod(typ reflect.Type) bool {
	method, ok := typ.MethodByName("FromTony")
	if !ok {
		// Check pointer receiver
		if typ.Kind() != reflect.Ptr {
			ptrType := reflect.PtrTo(typ)
			_, ok = ptrType.MethodByName("FromTony")
		}
		return ok
	}

	// Verify signature: FromTony(*ir.Node) error
	if method.Type.NumIn() != 2 || method.Type.NumOut() != 1 {
		return false
	}

	// Check input type (second arg, first is receiver)
	in1 := method.Type.In(1)
	out0 := method.Type.Out(0)

	// in1 should be *ir.Node, out0 should be error
	return in1.Kind() == reflect.Ptr && out0.Name() == "error"
}
