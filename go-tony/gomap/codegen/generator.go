package codegen

import (
	"fmt"
	"go/ast"
	"go/format"
	"reflect"
	"strings"

	"github.com/signadot/tony-format/go-tony/schema"
)

// GenerateCode generates Go code for ToTony() and FromTony() methods for all structs.
// Returns formatted Go source code.
func GenerateCode(structs []*StructInfo, schemas map[string]*schema.Schema, config *CodegenConfig) (string, error) {
	var buf strings.Builder

	// Write header
	buf.WriteString("// Code generated by tony-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", config.Package.Name))
	buf.WriteString("import (\n")
	buf.WriteString(`	"fmt"` + "\n")
	buf.WriteString(`	"strconv"` + "\n")
	buf.WriteString(`	"unsafe"` + "\n")
	buf.WriteString(`	"github.com/signadot/tony-format/go-tony/ir"` + "\n")
	buf.WriteString(")\n\n")

	// Generate methods for each struct
	for _, structInfo := range structs {
		// Skip if struct doesn't have schema tag
		if structInfo.StructSchema == nil {
			continue
		}

		// Get schema for this struct
		schemaName := structInfo.StructSchema.SchemaName
		s, ok := schemas[schemaName]
		if !ok {
			return "", fmt.Errorf("schema %q not found for struct %q", schemaName, structInfo.Name)
		}

		// Check if methods already exist (skip code generation if they do)
		// Note: We can't check at codegen time since we're generating the code.
		// This check would need to be done at runtime or via AST analysis.
		// For now, we'll always generate the methods.

		// Generate ToTony method
		toTonyCode, err := GenerateToTonyMethod(structInfo, s)
		if err != nil {
			return "", fmt.Errorf("failed to generate ToTony() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(toTonyCode)
		buf.WriteString("\n\n")

		// Generate FromTony method
		fromTonyCode, err := GenerateFromTonyMethod(structInfo, s)
		if err != nil {
			return "", fmt.Errorf("failed to generate FromTony() for %q: %w", structInfo.Name, err)
		}
		buf.WriteString(fromTonyCode)
		buf.WriteString("\n\n")
	}

	// Format the generated code
	codeStr := buf.String()
	formatted, err := format.Source([]byte(codeStr))
	if err != nil {
		// Return unformatted code if formatting fails (with error)
		// Include first 50 lines of code for debugging
		lines := strings.Split(codeStr, "\n")
		preview := strings.Join(lines[:min(50, len(lines))], "\n")
		// Show the problematic line if we can extract it from the error
		if len(lines) >= 191 {
			preview += fmt.Sprintf("\n\nLine 191: %s", lines[190])
		}
		return codeStr, fmt.Errorf("failed to format generated code: %w\nFirst 50 lines:\n%s", err, preview)
	}

	return string(formatted), nil
}

// GenerateToTonyMethod generates a ToTony() method for a struct.
func GenerateToTonyMethod(structInfo *StructInfo, s *schema.Schema) (string, error) {
	var buf strings.Builder

	// Method signature
	buf.WriteString(fmt.Sprintf("// ToTony converts %s to a Tony IR node.\n", structInfo.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) ToTony() (*ir.Node, error) {\n", structInfo.Name))
	buf.WriteString("	// Create IR object map\n")
	buf.WriteString("	irMap := make(map[string]*ir.Node)\n\n")

	// Get struct fields from schema
	// We need to use reflection to get the struct type
	// For now, we'll use the fields from StructInfo
	for _, field := range structInfo.Fields {
		if field.Omit {
			continue
		}

		// Get schema field name
		schemaFieldName := field.SchemaFieldName
		if schemaFieldName == "" {
			schemaFieldName = field.Name
		}

		// Handle optional fields (skip zero values)
		if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
			buf.WriteString(fmt.Sprintf("	// Field: %s (optional)\n", field.Name))
			if field.Type != nil && field.Type.Kind() == reflect.Ptr {
				buf.WriteString(fmt.Sprintf("	if s.%s != nil {\n", field.Name))
			} else {
				// Non-pointer optional field - check if zero value
				buf.WriteString(fmt.Sprintf("	if !isZeroValue_%s_%s(s.%s) {\n", structInfo.Name, field.Name, field.Name))
			}
		} else {
			buf.WriteString(fmt.Sprintf("	// Field: %s\n", field.Name))
		}

		// Generate code to convert field to IR node
		fieldCode, err := generateFieldToIR(structInfo, field, schemaFieldName)
		if err != nil {
			return "", fmt.Errorf("failed to generate field conversion for %q: %w", field.Name, err)
		}
		buf.WriteString(fieldCode)

		if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
			buf.WriteString("	}\n")
		}
		buf.WriteString("\n")
	}

	// Create IR node with schema tag
	schemaName := s.Signature.Name
	buf.WriteString(fmt.Sprintf("	// Create IR node with schema tag\n"))
	buf.WriteString(fmt.Sprintf("	node := ir.FromMap(irMap)\n"))
	buf.WriteString(fmt.Sprintf("	node.Tag = \"!%s\"\n", schemaName))
	buf.WriteString("	return node, nil\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateFieldToIR generates code to convert a struct field to an IR node.
func generateFieldToIR(structInfo *StructInfo, field *FieldInfo, schemaFieldName string) (string, error) {
	var buf strings.Builder

	if field.Type == nil {
		return "", fmt.Errorf("field %q has no type information", field.Name)
	}

	// Handle different field types
	switch field.Type.Kind() {
	case reflect.String:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromString(s.%s)\n", schemaFieldName, field.Name))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromInt64(int64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		// For unsigned types, we need to handle them carefully
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromInt64(int64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromFloat64(float64(s.%s))\n", schemaFieldName, field.Name))

	case reflect.Bool:
		buf.WriteString(fmt.Sprintf("		irMap[%q] = ir.FromBool(s.%s)\n", schemaFieldName, field.Name))

	case reflect.Ptr:
		// Pointer type - dereference and recurse
		elemType := field.Type.Elem()
		if elemType.Kind() == reflect.Struct {
			// Nested struct - call ToTony() method
			buf.WriteString(fmt.Sprintf("		if s.%s != nil {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			node, err := s.%s.ToTony()\n", field.Name))
			buf.WriteString("			if err != nil {\n")
			buf.WriteString("				return nil, err\n")
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = node\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else {
			// Pointer to primitive - handle based on element type
			fieldCode, err := generateFieldToIR(structInfo, &FieldInfo{
				Name: field.Name,
				Type: elemType,
			}, schemaFieldName)
			if err != nil {
				return "", err
			}
			// Wrap in nil check
			buf.WriteString(fmt.Sprintf("		if s.%s != nil {\n", field.Name))
			buf.WriteString(strings.Replace(fieldCode, fmt.Sprintf("s.%s", field.Name), fmt.Sprintf("*s.%s", field.Name), -1))
			buf.WriteString("		}\n")
		}

	case reflect.Slice, reflect.Array:
		// Slice/Array type
		elemType := field.Type.Elem()
		buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			slice := make([]*ir.Node, len(s.%s))\n", field.Name))
		buf.WriteString(fmt.Sprintf("			for i, v := range s.%s {\n", field.Name))
		if elemType.Kind() == reflect.Struct {
			// Slice of structs - call ToTony()
			buf.WriteString("				node, err := v.ToTony()\n")
			buf.WriteString("				if err != nil {\n")
			buf.WriteString("					return nil, fmt.Errorf(\"failed to convert slice element %%d: %%w\", i, err)\n")
			buf.WriteString("				}\n")
			buf.WriteString("				slice[i] = node\n")
		} else {
			// Slice of primitives - generate element conversion
			elemCode, err := generatePrimitiveToIR("v", elemType)
			if err != nil {
				return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
			}
			buf.WriteString(fmt.Sprintf("				slice[i] = %s\n", elemCode))
		}
		buf.WriteString("			}\n")
		buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromSlice(slice)\n", schemaFieldName))
		buf.WriteString("		}\n")

	case reflect.Map:
		// Map type
		keyType := field.Type.Key()
		valueType := field.Type.Elem()
		
		if keyType.Kind() == reflect.Uint32 {
			// Sparse array (map[uint32]T)
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			intKeysMap := make(map[uint32]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			if valueType.Kind() == reflect.Struct {
				buf.WriteString("				node, err := v.ToTony()\n")
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %%d: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				intKeysMap[k] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				intKeysMap[k] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromIntKeysMap(intKeysMap)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.String {
			// Regular map (map[string]T)
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			if valueType.Kind() == reflect.Struct {
				buf.WriteString("				node, err := v.ToTony()\n")
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %%q: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				mapNodes[k] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[k] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Interface {
			// Map with interface{} (any) keys - convert keys to strings
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			buf.WriteString("				// Convert interface{} key to string\n")
			buf.WriteString("				kStr := fmt.Sprintf(\"%v\", k)\n")
			if valueType.Kind() == reflect.Struct {
				buf.WriteString("				node, err := v.ToTony()\n")
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %%v: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				mapNodes[kStr] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[kStr] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Ptr {
			// Map with pointer keys - convert pointers to strings
			buf.WriteString(fmt.Sprintf("		if len(s.%s) > 0 {\n", field.Name))
			buf.WriteString(fmt.Sprintf("			mapNodes := make(map[string]*ir.Node)\n"))
			buf.WriteString(fmt.Sprintf("			for k, v := range s.%s {\n", field.Name))
			buf.WriteString("				// Convert pointer key to string representation\n")
			buf.WriteString("				kStr := fmt.Sprintf(\"%p\", k)\n")
			if valueType.Kind() == reflect.Struct {
				buf.WriteString("				node, err := v.ToTony()\n")
				buf.WriteString("				if err != nil {\n")
				buf.WriteString("					return nil, fmt.Errorf(\"failed to convert map value at key %%p: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				mapNodes[kStr] = node\n")
			} else {
				valueCode, err := generatePrimitiveToIR("v", valueType)
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				mapNodes[kStr] = %s\n", valueCode))
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			irMap[%q] = ir.FromMap(mapNodes)\n", schemaFieldName))
			buf.WriteString("		}\n")
		} else {
			return "", fmt.Errorf("unsupported map key type: %v (only string, uint32, interface{}, and pointer types are supported)", keyType.Kind())
		}

	case reflect.Interface:
		// Interface{} type - use reflection-based conversion
		// For codegen, we'll use a helper that calls ToIR recursively
		buf.WriteString(fmt.Sprintf("		if s.%s != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			// Interface{} conversion requires runtime reflection\n"))
		buf.WriteString(fmt.Sprintf("			node, err := toIRInterface(s.%s)\n", field.Name))
		buf.WriteString("			if err != nil {\n")
		buf.WriteString(fmt.Sprintf("				return nil, fmt.Errorf(\"failed to convert field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("			}\n")
		buf.WriteString(fmt.Sprintf("			irMap[%q] = node\n", schemaFieldName))
		buf.WriteString("		}\n")

	case reflect.Struct:
		// Nested struct - call ToTony() method
		buf.WriteString(fmt.Sprintf("		node, err := s.%s.ToTony()\n", field.Name))
		buf.WriteString("		if err != nil {\n")
		buf.WriteString(fmt.Sprintf("			return nil, fmt.Errorf(\"failed to convert field %%q: %%w\", %q, err)\n", field.Name))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		irMap[%q] = node\n", schemaFieldName))

	default:
		return "", fmt.Errorf("unsupported field type: %v", field.Type.Kind())
	}

	return buf.String(), nil
}

// generatePrimitiveToIR generates code to convert a primitive value to an IR node.
// Returns the code expression (e.g., "ir.FromString(v)").
func generatePrimitiveToIR(varName string, typ reflect.Type) (string, error) {
	switch typ.Kind() {
	case reflect.String:
		return fmt.Sprintf("ir.FromString(%s)", varName), nil
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return fmt.Sprintf("ir.FromInt64(int64(%s))", varName), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("ir.FromInt64(int64(%s))", varName), nil
	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("ir.FromFloat64(float64(%s))", varName), nil
	case reflect.Bool:
		return fmt.Sprintf("ir.FromBool(%s)", varName), nil
	default:
		return "", fmt.Errorf("unsupported primitive type: %v", typ.Kind())
	}
}

// GenerateFromTonyMethod generates a FromTony() method for a struct.
func GenerateFromTonyMethod(structInfo *StructInfo, s *schema.Schema) (string, error) {
	var buf strings.Builder

	// Method signature
	buf.WriteString(fmt.Sprintf("// FromTony populates %s from a Tony IR node.\n", structInfo.Name))
	buf.WriteString(fmt.Sprintf("func (s *%s) FromTony(node *ir.Node) error {\n", structInfo.Name))
	buf.WriteString("	// Validate IR node type\n")
	buf.WriteString("	if node.Type != ir.ObjectType {\n")
	buf.WriteString("		return fmt.Errorf(\"expected object type, got %v\", node.Type)\n")
	buf.WriteString("	}\n\n")

	// Get struct fields from schema using GetStructFields
	// For now, we'll iterate over StructInfo.Fields
	for _, field := range structInfo.Fields {
		if field.Omit {
			continue
		}

		// Get schema field name
		schemaFieldName := field.SchemaFieldName
		if schemaFieldName == "" {
			schemaFieldName = field.Name
		}

		// Generate code to extract field from IR node
		fieldCode, err := generateFieldFromIR(structInfo, field, schemaFieldName)
		if err != nil {
			return "", fmt.Errorf("failed to generate field extraction for %q: %w", field.Name, err)
		}
		buf.WriteString(fieldCode)
		buf.WriteString("\n")
	}

	// Handle allowExtra flag
	if structInfo.StructSchema != nil && structInfo.StructSchema.AllowExtra {
		buf.WriteString("	// allowExtra is true, so extra fields are ignored\n")
	} else {
		// Validate no extra fields (optional - can be added later)
	}

	buf.WriteString("	return nil\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// getTypeName returns the type name for code generation.
// Uses StructTypeName if available (for struct types), otherwise uses Type.Name().
func getTypeName(typ reflect.Type, structTypeName string) string {
	if structTypeName != "" {
		return structTypeName
	}
	return typ.Name()
}

// generateFieldFromIR generates code to extract a struct field from an IR node.
func generateFieldFromIR(structInfo *StructInfo, field *FieldInfo, schemaFieldName string) (string, error) {
	var buf strings.Builder

	if field.Type == nil {
		return "", fmt.Errorf("field %q has no type information", field.Name)
	}

	// Get field from IR node
	buf.WriteString(fmt.Sprintf("	// Field: %s\n", field.Name))
	if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
		buf.WriteString(fmt.Sprintf("	if fieldNode := ir.Get(node, %q); fieldNode != nil {\n", schemaFieldName))
	} else {
		// Required field
		if field.Required {
			buf.WriteString(fmt.Sprintf("	fieldNode := ir.Get(node, %q)\n", schemaFieldName))
			buf.WriteString("	if fieldNode == nil {\n")
			buf.WriteString(fmt.Sprintf("		return fmt.Errorf(\"required field %%q is missing\", %q)\n", schemaFieldName))
			buf.WriteString("	}\n")
		} else {
			buf.WriteString(fmt.Sprintf("	if fieldNode := ir.Get(node, %q); fieldNode != nil {\n", schemaFieldName))
		}
	}

	// Handle different field types
	switch field.Type.Kind() {
	case reflect.String:
		buf.WriteString("		if fieldNode.Type != ir.StringType {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected string, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = fieldNode.String\n", field.Name))

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString("		if fieldNode.Int64 == nil {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		// Handle overflow checking for smaller int types
		intVal := "*fieldNode.Int64"
		if field.Type.Kind() == reflect.Int8 {
			buf.WriteString(fmt.Sprintf("		if %s < -128 || %s > 127 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows int8\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Int16 {
			buf.WriteString(fmt.Sprintf("		if %s < -32768 || %s > 32767 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows int16\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Int32 {
			buf.WriteString(fmt.Sprintf("		if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows int32\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		}
		buf.WriteString(fmt.Sprintf("		s.%s = %s(%s)\n", field.Name, field.Type.Name(), intVal))

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString("		if fieldNode.Int64 == nil {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		// Check for negative values and overflow
		intVal := "*fieldNode.Int64"
		buf.WriteString(fmt.Sprintf("		if %s < 0 {\n", intVal))
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: negative value %%d for unsigned type\", %q, %s)\n", schemaFieldName, intVal))
		buf.WriteString("		}\n")
		if field.Type.Kind() == reflect.Uint8 {
			buf.WriteString(fmt.Sprintf("		if %s > 255 {\n", intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows uint8\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Uint16 {
			buf.WriteString(fmt.Sprintf("		if %s > 65535 {\n", intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows uint16\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		} else if field.Type.Kind() == reflect.Uint32 {
			buf.WriteString(fmt.Sprintf("		if %s > 4294967295 {\n", intVal))
			buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: value %%d overflows uint32\", %q, %s)\n", schemaFieldName, intVal))
			buf.WriteString("		}\n")
		}
		buf.WriteString(fmt.Sprintf("		s.%s = %s(%s)\n", field.Name, field.Type.Name(), intVal))

	case reflect.Float32, reflect.Float64:
		buf.WriteString("		if fieldNode.Float64 == nil {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected number, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = %s(*fieldNode.Float64)\n", field.Name, field.Type.Name()))

	case reflect.Bool:
		buf.WriteString("		if fieldNode.Type != ir.BoolType {\n")
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: expected bool, got %%v\", %q, fieldNode.Type)\n", schemaFieldName))
		buf.WriteString("		}\n")
		buf.WriteString(fmt.Sprintf("		s.%s = fieldNode.Bool\n", field.Name))

	case reflect.Ptr:
		// Pointer type
		elemType := field.Type.Elem()
		if elemType.Kind() == reflect.Struct {
			// Pointer to struct - call FromTony()
			structName := getTypeName(elemType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("		s.%s = &%s{}\n", field.Name, structName))
			buf.WriteString(fmt.Sprintf("		if err := s.%s.FromTony(fieldNode); err != nil {\n", field.Name))
			buf.WriteString("			return err\n")
			buf.WriteString("		}\n")
		} else {
			// Pointer to primitive
			fieldCode, err := generateFieldFromIR(structInfo, &FieldInfo{
				Name: "val",
				Type: elemType,
			}, "field")
			if err != nil {
				return "", err
			}
			// Adapt the code for pointer assignment
			buf.WriteString(fmt.Sprintf("		val := new(%s)\n", getTypeName(elemType, "")))
			// Extract assignment and adapt
			if strings.Contains(fieldCode, "val =") {
				assignment := extractAssignment(fieldCode)
				buf.WriteString(fmt.Sprintf("		%s\n", assignment))
				buf.WriteString(fmt.Sprintf("		s.%s = val\n", field.Name))
			}
		}

	case reflect.Slice, reflect.Array:
		// Slice/Array type
		elemType := field.Type.Elem()
		buf.WriteString("		if fieldNode.Type == ir.ArrayType {\n")
		structName := getTypeName(elemType, field.StructTypeName)
		buf.WriteString(fmt.Sprintf("			slice := make([]%s, len(fieldNode.Values))\n", structName))
		buf.WriteString("			for i, v := range fieldNode.Values {\n")
		if elemType.Kind() == reflect.Struct {
			// Slice of structs - call FromTony()
			buf.WriteString(fmt.Sprintf("				elem := %s{}\n", structName))
			buf.WriteString("				if err := elem.FromTony(v); err != nil {\n")
			buf.WriteString("					return fmt.Errorf(\"slice element %%d: %%w\", i, err)\n")
			buf.WriteString("				}\n")
			buf.WriteString("				slice[i] = elem\n")
		} else {
			// Slice of primitives
			// Generate code with a context variable that will be formatted
			buf.WriteString("				ctx := fmt.Sprintf(\"slice element %d\", i)\n")
			elemCode, err := generatePrimitiveFromIR("v", elemType, "ctx")
			if err != nil {
				return "", fmt.Errorf("unsupported slice element type %v: %w", elemType, err)
			}
			buf.WriteString(fmt.Sprintf("				var elem %s\n", getTypeName(elemType, "")))
			buf.WriteString(fmt.Sprintf("				%s\n", elemCode))
			buf.WriteString("				slice[i] = elem\n")
		}
		buf.WriteString("			}\n")
		buf.WriteString(fmt.Sprintf("			s.%s = slice\n", field.Name))
		buf.WriteString("		}\n")

	case reflect.Map:
		// Map type
		keyType := field.Type.Key()
		valueType := field.Type.Elem()
		
		if keyType.Kind() == reflect.Uint32 {
			// Sparse array (map[uint32]T)
			buf.WriteString("		if fieldNode.Type == ir.ObjectType && fieldNode.Tag == \"!sparsearray\" {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("			m := make(map[uint32]%s)\n", structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for kStr, v := range irMap {\n")
			buf.WriteString("				k, err := strconv.ParseUint(kStr, 10, 32)\n")
			buf.WriteString("				if err != nil {\n")
			buf.WriteString("					return fmt.Errorf(\"invalid sparse array key %q: %w\", kStr, err)\n")
			buf.WriteString("				}\n")
			if valueType.Kind() == reflect.Struct {
				buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
				buf.WriteString("				if err := val.FromTony(v); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"map value at key %d: %w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				m[uint32(k)] = val\n")
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %d\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[uint32(k)] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.String {
			// Regular map (map[string]T)
			buf.WriteString("		if fieldNode.Type == ir.ObjectType {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("			m := make(map[string]%s)\n", structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for k, v := range irMap {\n")
			if valueType.Kind() == reflect.Struct {
				buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
				buf.WriteString("				if err := val.FromTony(v); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"map value at key %q: %w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				m[k] = val\n")
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %q\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[k] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Interface {
			// Map with interface{} (any) keys - keys were converted to strings
			buf.WriteString("		if fieldNode.Type == ir.ObjectType {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			buf.WriteString(fmt.Sprintf("			m := make(map[interface{}]%s)\n", structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for kStr, v := range irMap {\n")
			buf.WriteString("				// Convert string key back to interface{}\n")
			buf.WriteString("				var k interface{} = kStr\n")
			if valueType.Kind() == reflect.Struct {
				buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
				buf.WriteString("				if err := val.FromTony(v); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"map value at key %v: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				m[k] = val\n")
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %v\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[k] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else if keyType.Kind() == reflect.Ptr {
			// Map with pointer keys - keys were converted to strings (pointer addresses)
			// Note: We can't reconstruct the original pointer from the address string,
			// so this is a lossy conversion. The pointer address is preserved as a string.
			buf.WriteString("		// Note: Pointer keys cannot be fully reconstructed from serialized form\n")
			buf.WriteString("		// Pointer addresses are preserved as strings, but original pointers are lost\n")
			buf.WriteString("		if fieldNode.Type == ir.ObjectType {\n")
			structName := getTypeName(valueType, field.StructTypeName)
			elemType := keyType.Elem()
			// Extract key struct name from AST if available (for pointer keys like *X)
			keyStructNameFromAST := ""
			if field.ASTType != nil {
				if mapType, ok := field.ASTType.(*ast.MapType); ok {
					if keyIdent, ok := mapType.Key.(*ast.StarExpr); ok {
						if ident, ok := keyIdent.X.(*ast.Ident); ok {
							keyStructNameFromAST = ident.Name
						}
					}
				}
			}
			// Use AST name if available, otherwise try type name, fallback to interface{}
			keyStructName := keyStructNameFromAST
			if keyStructName == "" {
				keyStructName = elemType.Name()
			}
			if keyStructName == "" {
				keyStructName = "interface{}"
			}
			buf.WriteString(fmt.Sprintf("			m := make(map[*%s]%s)\n", keyStructName, structName))
			buf.WriteString("			irMap := ir.ToMap(fieldNode)\n")
			buf.WriteString("			for kStr, v := range irMap {\n")
			buf.WriteString("				// Parse pointer address from string (format: 0x...)\n")
			buf.WriteString("				var ptrAddr uintptr\n")
			buf.WriteString("				if _, err := fmt.Sscanf(kStr, \"0x%%x\", &ptrAddr); err != nil {\n")
			buf.WriteString("					return fmt.Errorf(\"invalid pointer address format %%q: %%w\", kStr, err)\n")
			buf.WriteString("				}\n")
			buf.WriteString(fmt.Sprintf("				k := (*%s)(unsafe.Pointer(ptrAddr))\n", keyStructName))
			if valueType.Kind() == reflect.Struct {
				buf.WriteString(fmt.Sprintf("				val := %s{}\n", structName))
				buf.WriteString("				if err := val.FromTony(v); err != nil {\n")
				buf.WriteString("					return fmt.Errorf(\"map value at key %p: %%w\", k, err)\n")
				buf.WriteString("				}\n")
				buf.WriteString("				m[k] = val\n")
			} else {
				buf.WriteString("				ctx := fmt.Sprintf(\"map value at key %p\", k)\n")
				valueCode, err := generatePrimitiveFromIR("v", valueType, "ctx")
				if err != nil {
					return "", fmt.Errorf("unsupported map value type %v: %w", valueType, err)
				}
				buf.WriteString(fmt.Sprintf("				var val %s\n", getTypeName(valueType, "")))
				buf.WriteString(fmt.Sprintf("				%s\n", valueCode))
				buf.WriteString("				m[k] = val\n")
			}
			buf.WriteString("			}\n")
			buf.WriteString(fmt.Sprintf("			s.%s = m\n", field.Name))
			buf.WriteString("		}\n")
		} else {
			return "", fmt.Errorf("unsupported map key type: %v (only string, uint32, interface{}, and pointer types are supported)", keyType.Kind())
		}

	case reflect.Interface:
		// Interface{} type - use reflection-based conversion
		buf.WriteString(fmt.Sprintf("		// Interface{} conversion requires runtime reflection\n"))
		buf.WriteString(fmt.Sprintf("		if err := fromIRInterface(fieldNode, &s.%s); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: %%w\", %q, err)\n", schemaFieldName))
		buf.WriteString("		}\n")

	case reflect.Struct:
		// Nested struct - call FromTony()
		buf.WriteString(fmt.Sprintf("		if err := s.%s.FromTony(fieldNode); err != nil {\n", field.Name))
		buf.WriteString(fmt.Sprintf("			return fmt.Errorf(\"field %%q: %%w\", %q, err)\n", schemaFieldName))
		buf.WriteString("		}\n")

	default:
		return "", fmt.Errorf("unsupported field type: %v", field.Type.Kind())
	}

	if field.Optional || (field.Type != nil && field.Type.Kind() == reflect.Ptr) {
		buf.WriteString("	}\n")
	} else if !field.Required {
		buf.WriteString("	}\n")
	}

	return buf.String(), nil
}

// generatePrimitiveFromIR generates code to extract a primitive value from an IR node.
// Returns the code statement (e.g., "if v.Type != ir.StringType { return fmt.Errorf(...) }; elem = v.String").
// The context parameter can contain format specifiers like %d, %q, etc. that will be used in error messages.
func generatePrimitiveFromIR(varName string, typ reflect.Type, context string) (string, error) {
	var buf strings.Builder
	
	switch typ.Kind() {
	case reflect.String:
		buf.WriteString(fmt.Sprintf("if %s.Type != ir.StringType {\n", varName))
		// Use %q to properly quote the context string in the error message
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected string, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s.String", varName))
		
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString(fmt.Sprintf("if %s.Int64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		intVal := fmt.Sprintf("*%s.Int64", varName)
		// Overflow checking
		if typ.Kind() == reflect.Int8 {
			buf.WriteString(fmt.Sprintf("if %s < -128 || %s > 127 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int8\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Int16 {
			buf.WriteString(fmt.Sprintf("if %s < -32768 || %s > 32767 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int16\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Int32 {
			buf.WriteString(fmt.Sprintf("if %s < -2147483648 || %s > 2147483647 {\n", intVal, intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows int32\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		}
		buf.WriteString(fmt.Sprintf("elem = %s(%s)", typ.Name(), intVal))
		
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString(fmt.Sprintf("if %s.Int64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		intVal := fmt.Sprintf("*%s.Int64", varName)
		buf.WriteString(fmt.Sprintf("if %s < 0 {\n", intVal))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: negative value %%d for unsigned type\", %s, %s)\n", context, intVal))
		buf.WriteString("}\n")
		if typ.Kind() == reflect.Uint8 {
			buf.WriteString(fmt.Sprintf("if %s > 255 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint8\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Uint16 {
			buf.WriteString(fmt.Sprintf("if %s > 65535 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint16\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		} else if typ.Kind() == reflect.Uint32 {
			buf.WriteString(fmt.Sprintf("if %s > 4294967295 {\n", intVal))
			buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: value %%d overflows uint32\", %s, %s)\n", context, intVal))
			buf.WriteString("}\n")
		}
		buf.WriteString(fmt.Sprintf("elem = %s(%s)", typ.Name(), intVal))
		
	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("if %s.Float64 == nil {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected number, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s(*%s.Float64)", typ.Name(), varName))
		
	case reflect.Bool:
		buf.WriteString(fmt.Sprintf("if %s.Type != ir.BoolType {\n", varName))
		buf.WriteString(fmt.Sprintf("	return fmt.Errorf(\"%%s: expected bool, got %%v\", %s, %s.Type)\n", context, varName))
		buf.WriteString("}\n")
		buf.WriteString(fmt.Sprintf("elem = %s.Bool", varName))
		
	default:
		return "", fmt.Errorf("unsupported primitive type: %v", typ.Kind())
	}
	
	return buf.String(), nil
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// Helper function to extract assignment from generated code
func extractAssignment(code string) string {
	lines := strings.Split(code, "\n")
	for _, line := range lines {
		if strings.Contains(line, "=") && !strings.Contains(line, "if") && !strings.Contains(line, "return") {
			return strings.TrimSpace(line)
		}
	}
	return ""
}

// HasToTonyMethod checks if a type has a ToTony() method.
func HasToTonyMethod(typ reflect.Type) bool {
	method, ok := typ.MethodByName("ToTony")
	if !ok {
		// Check pointer receiver
		if typ.Kind() != reflect.Ptr {
			ptrType := reflect.PtrTo(typ)
			_, ok = ptrType.MethodByName("ToTony")
		}
		return ok
	}

	// Verify signature: ToTony() (*ir.Node, error)
	if method.Type.NumIn() != 1 || method.Type.NumOut() != 2 {
		return false
	}

	// Check return types
	out0 := method.Type.Out(0)
	out1 := method.Type.Out(1)

	// out0 should be *ir.Node, out1 should be error
	return out0.Kind() == reflect.Ptr && out1.Name() == "error"
}

// HasFromTonyMethod checks if a type has a FromTony() method.
func HasFromTonyMethod(typ reflect.Type) bool {
	method, ok := typ.MethodByName("FromTony")
	if !ok {
		// Check pointer receiver
		if typ.Kind() != reflect.Ptr {
			ptrType := reflect.PtrTo(typ)
			_, ok = ptrType.MethodByName("FromTony")
		}
		return ok
	}

	// Verify signature: FromTony(*ir.Node) error
	if method.Type.NumIn() != 2 || method.Type.NumOut() != 1 {
		return false
	}

	// Check input type (second arg, first is receiver)
	in1 := method.Type.In(1)
	out0 := method.Type.Out(0)

	// in1 should be *ir.Node, out0 should be error
	return in1.Kind() == reflect.Ptr && out0.Name() == "error"
}
