// Code generated by tony-codegen. DO NOT EDIT.

package pkg2

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Meta to a Tony IR node.
func (s *Meta) ToTonyIR(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: A
	irMap["a"] = ir.FromInt(int64(s.A))

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!meta"), nil
}

// FromTonyIR populates Meta from a Tony IR node.
func (s *Meta) FromTonyIR(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "a":
			// Field: A
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "a", fieldNode.Type)
			}
			s.A = int(*fieldNode.Int64)
		}
	}

	return nil
}

// ToTony converts Meta to Tony format bytes.
func (s *Meta) ToTony(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Meta.
func (s *Meta) FromTony(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Body to a Tony IR node.
func (s *Body) ToTonyIR(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: B
	irMap["b"] = ir.FromString(s.B)

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!body"), nil
}

// FromTonyIR populates Body from a Tony IR node.
func (s *Body) FromTonyIR(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "b":
			// Field: B
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "b", fieldNode.Type)
			}
			s.B = fieldNode.String
		}
	}

	return nil
}

// ToTony converts Body to Tony format bytes.
func (s *Body) ToTony(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Body.
func (s *Body) FromTony(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Compound to a Tony IR node.
func (s *Compound) ToTonyIR(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Meta
	node, err := s.Meta.ToTonyIR(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Meta", err)
	}
	irMap["meta"] = node

	// Field: Body
	node, err = s.Body.ToTonyIR(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Body", err)
	}
	irMap["body"] = node

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!compound"), nil
}

// FromTonyIR populates Compound from a Tony IR node.
func (s *Compound) FromTonyIR(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "meta":
			// Field: Meta
			if err := s.Meta.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "meta", err)
			}
		case "body":
			// Field: Body
			if err := s.Body.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "body", err)
			}
		}
	}

	return nil
}

// ToTony converts Compound to Tony format bytes.
func (s *Compound) ToTony(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Compound.
func (s *Compound) FromTony(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
