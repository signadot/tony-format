// Code generated by tony-codegen. DO NOT EDIT.

package pkg

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Inner to a Tony IR node.
func (s *Inner) ToTonyIR(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: I
	irMap["i"] = ir.FromInt(int64(s.I))

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!inner"), nil
}

// FromTonyIR populates Inner from a Tony IR node.
func (s *Inner) FromTonyIR(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "i":
			// Field: I
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "i", fieldNode.Type)
			}
			s.I = int(*fieldNode.Int64)
		}
	}

	return nil
}

// ToTony converts Inner to Tony format bytes.
func (s *Inner) ToTony(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Inner.
func (s *Inner) FromTony(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Outer to a Tony IR node.
func (s *Outer) ToTonyIR(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: I
	irMap["i"] = ir.FromInt(int64(s.I))

	// Field: F
	irMap["f"] = ir.FromFloat64(float64(s.F))

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!outer"), nil
}

// FromTonyIR populates Outer from a Tony IR node.
func (s *Outer) FromTonyIR(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "i":
			// Field: I
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "i", fieldNode.Type)
			}
			s.I = int(*fieldNode.Int64)
		case "f":
			// Field: F
			if fieldNode.Float64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "f", fieldNode.Type)
			}
			s.F = float64(*fieldNode.Float64)
		}
	}

	return nil
}

// ToTony converts Outer to Tony format bytes.
func (s *Outer) ToTony(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Outer.
func (s *Outer) FromTony(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
