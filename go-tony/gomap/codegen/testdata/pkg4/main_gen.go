// Code generated by tony-codegen. DO NOT EDIT.

package main

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/format"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Dir to a Tony IR node.
func (s *Dir) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Suffix
	irMap["Suffix"] = ir.FromString(s.Suffix)

	// Field: DestDir
	irMap["DestDir"] = ir.FromString(s.DestDir)

	// Field: Sources
	if len(s.Sources) > 0 {
		slice := make([]*ir.Node, len(s.Sources))
		for i, v := range s.Sources {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["Sources"] = ir.FromSlice(slice)
	}

	// Field: Env
	if len(s.Env) > 0 {
		mapNodes := make(map[string]*ir.Node)
		for k, v := range s.Env {
			mapNodes[k] = v
		}
		irMap["Env"] = ir.FromMap(mapNodes)
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!dir"), nil
}

// FromTonyIR populates Dir from a Tony IR node.
func (s *Dir) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Dir, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "Suffix":
			// Field: Suffix
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "Suffix", fieldNode.Type)
			}
			s.Suffix = fieldNode.String
		case "DestDir":
			// Field: DestDir
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "DestDir", fieldNode.Type)
			}
			s.DestDir = fieldNode.String
		case "Sources":
			// Field: Sources
			if fieldNode.Type == ir.ArrayType {
				slice := make([]DirSource, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := DirSource{}
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.Sources = slice
			}
		case "Env":
			// Field: Env
			if fieldNode.Type == ir.ObjectType {
				m := make(map[string]*ir.Node)
				irMap := ir.ToMap(fieldNode)
				for k, v := range irMap {
					m[k] = v
				}
				s.Env = m
			}
		}
	}

	return nil
}

// ToTony converts Dir to Tony format bytes.
func (s *Dir) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Dir.
func (s *Dir) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DirSource to a Tony IR node.
func (s *DirSource) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Format (optional)
	if s.Format != nil {
		if s.Format != nil {
			irMap["Format"] = ir.FromInt(int64(*s.Format))
		}
	}

	// Field: Exec (optional)
	if s.Exec != nil {
		if s.Exec != nil {
			irMap["Exec"] = ir.FromString(*s.Exec)
		}
	}

	// Field: Dir (optional)
	if s.Dir != nil {
		if s.Dir != nil {
			irMap["Dir"] = ir.FromString(*s.Dir)
		}
	}

	// Field: URL (optional)
	if s.URL != nil {
		if s.URL != nil {
			irMap["URL"] = ir.FromString(*s.URL)
		}
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!dirsource"), nil
}

// FromTonyIR populates DirSource from a Tony IR node.
func (s *DirSource) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DirSource, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "Format":
			// Field: Format
			val := new(format.Format)
			if fieldNode.Int64 == nil {
				return fmt.Errorf("%s: expected number, got %v", "field \"Format\"", fieldNode.Type)
			}
			*val = format.Format(*fieldNode.Int64)
			s.Format = val
		case "Exec":
			// Field: Exec
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"Exec\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.Exec = val
		case "Dir":
			// Field: Dir
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"Dir\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.Dir = val
		case "URL":
			// Field: URL
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"URL\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.URL = val
		}
	}

	return nil
}

// ToTony converts DirSource to Tony format bytes.
func (s *DirSource) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DirSource.
func (s *DirSource) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
