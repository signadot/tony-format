// Code generated by tony-codegen. DO NOT EDIT.

package dirbuild

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/format"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Dir to a Tony IR node.
func (s *Dir) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Suffix
	irMap["suffix"] = ir.FromString(s.Suffix)

	// Field: DestDir
	irMap["destDir"] = ir.FromString(s.DestDir)

	// Field: Sources
	if len(s.Sources) > 0 {
		slice := make([]*ir.Node, len(s.Sources))
		for i, v := range s.Sources {
			node, err = v.ToTonyIR()
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["sources"] = ir.FromSlice(slice)
	}

	// Field: Patches
	if len(s.Patches) > 0 {
		slice := make([]*ir.Node, len(s.Patches))
		for i, v := range s.Patches {
			node, err = v.ToTonyIR()
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["patches"] = ir.FromSlice(slice)
	}

	// Field: Env
	if len(s.Env) > 0 {
		mapNodes := make(map[string]*ir.Node)
		for k, v := range s.Env {
			mapNodes[k] = v
		}
		irMap["env"] = ir.FromMap(mapNodes)
	}

	return ir.FromMap(irMap).WithTag("!dir"), nil
}

// FromTonyIR populates Dir from a Tony IR node.
func (s *Dir) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Dir, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "suffix":
			// Field: Suffix
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "suffix", fieldNodeUnwrapped.Type)
			}
			s.Suffix = fieldNodeUnwrapped.String
		case "destDir":
			// Field: DestDir
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "destDir", fieldNodeUnwrapped.Type)
			}
			s.DestDir = fieldNodeUnwrapped.String
		case "sources":
			// Field: Sources
			if fieldNodeUnwrapped.Type == ir.ArrayType {
				slice := make([]DirSource, len(fieldNodeUnwrapped.Values))
				for i, v := range fieldNodeUnwrapped.Values {
					elem := DirSource{}
					if err := elem.FromTonyIR(v); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.Sources = slice
			}
		case "patches":
			// Field: Patches
			if fieldNodeUnwrapped.Type == ir.ArrayType {
				slice := make([]DirPatch, len(fieldNodeUnwrapped.Values))
				for i, v := range fieldNodeUnwrapped.Values {
					elem := DirPatch{}
					if err := elem.FromTonyIR(v); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.Patches = slice
			}
		case "env":
			// Field: Env
			if fieldNodeUnwrapped.Type == ir.ObjectType {
				m := make(map[string]*ir.Node)
				irMap := ir.ToMap(fieldNodeUnwrapped)
				for k, v := range irMap {
					val := new(ir.Node)
					if err := val.FromTonyIR(v); err != nil {
						return fmt.Errorf("failed to convert map value at key %q: %w", k, err)
					}
					m[k] = val
				}
				s.Env = m
			}
		}
	}

	return nil
}

// ToTony converts Dir to Tony format bytes.
func (s *Dir) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Dir.
func (s *Dir) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DirSource to a Tony IR node.
func (s *DirSource) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Format (optional)
	if s.Format != nil {
		if txt, err := s.Format.MarshalText(); err != nil {
			return nil, fmt.Errorf("failed to marshal field %q: %w", "Format", err)
		} else {
			irMap["format"] = ir.FromString(string(txt))
		}
	}

	// Field: Exec (optional)
	if s.Exec != nil {
		irMap["exec"] = ir.FromString(*s.Exec)
	}

	// Field: Dir (optional)
	if s.Dir != nil {
		irMap["dir"] = ir.FromString(*s.Dir)
	}

	// Field: URL (optional)
	if s.URL != nil {
		irMap["url"] = ir.FromString(*s.URL)
	}

	// Field: If
	irMap["if"] = ir.FromString(s.If)

	return ir.FromMap(irMap).WithTag("!dirsource"), nil
}

// FromTonyIR populates DirSource from a Tony IR node.
func (s *DirSource) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DirSource, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "format":
			if fieldNodeUnwrapped.Type == ir.NullType {
				s.Format = nil
			} else if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string for TextUnmarshaler, got %v", "format", fieldNodeUnwrapped.Type)
			} else {
				if s.Format == nil {
					s.Format = new(format.Format)
				}
				if err := s.Format.UnmarshalText([]byte(fieldNodeUnwrapped.String)); err != nil {
					return fmt.Errorf("field %q: failed to unmarshal text: %w", "format", err)
				}
			}
		case "exec":
			// Field: Exec
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"exec\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.Exec = val
			}
		case "dir":
			// Field: Dir
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"dir\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.Dir = val
			}
		case "url":
			// Field: URL
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"url\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.URL = val
			}
		case "if":
			// Field: If
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "if", fieldNodeUnwrapped.Type)
			}
			s.If = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts DirSource to Tony format bytes.
func (s *DirSource) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DirSource.
func (s *DirSource) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DirPatch to a Tony IR node.
func (s *DirPatch) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Match (optional)
	if s.Match != nil {
		irMap["match"] = s.Match
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		irMap["patch"] = s.Patch
	}

	// Field: File
	irMap["file"] = ir.FromString(s.File)

	// Field: If
	irMap["if"] = ir.FromString(s.If)

	return ir.FromMap(irMap).WithTag("!dirpatch"), nil
}

// FromTonyIR populates DirPatch from a Tony IR node.
func (s *DirPatch) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DirPatch, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "match":
			if gomap.GetUnmapComments(opts...) {
				s.Match = fieldNode
			} else {
				s.Match = fieldNodeUnwrapped
			}
		case "patch":
			if gomap.GetUnmapComments(opts...) {
				s.Patch = fieldNode
			} else {
				s.Patch = fieldNodeUnwrapped
			}
		case "file":
			// Field: File
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "file", fieldNodeUnwrapped.Type)
			}
			s.File = fieldNodeUnwrapped.String
		case "if":
			// Field: If
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "if", fieldNodeUnwrapped.Type)
			}
			s.If = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts DirPatch to Tony format bytes.
func (s *DirPatch) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DirPatch.
func (s *DirPatch) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
