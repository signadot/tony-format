// Code generated by tony-codegen. DO NOT EDIT.

package dirbuild

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/format"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTony converts Dir to a Tony IR node.
func (s *Dir) ToTony(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Suffix
	irMap["Suffix"] = ir.FromString(s.Suffix)

	// Field: DestDir
	irMap["DestDir"] = ir.FromString(s.DestDir)

	// Field: Sources
	if len(s.Sources) > 0 {
		slice := make([]*ir.Node, len(s.Sources))
		for i, v := range s.Sources {
			node, err := v.ToTony(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["Sources"] = ir.FromSlice(slice)
	}

	// Field: Patches
	if len(s.Patches) > 0 {
		slice := make([]*ir.Node, len(s.Patches))
		for i, v := range s.Patches {
			node, err := v.ToTony(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["Patches"] = ir.FromSlice(slice)
	}

	// Field: Env
	if len(s.Env) > 0 {
		mapNodes := make(map[string]*ir.Node)
		for k, v := range s.Env {
			mapNodes[k] = v
		}
		irMap["Env"] = ir.FromMap(mapNodes)
	}

	// Create IR node with schema tag
	node := ir.FromMap(irMap)
	node.Tag = "!dir"
	return node, nil
}

// FromTony populates Dir from a Tony IR node.
func (s *Dir) FromTony(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	// Field: Suffix
	if fieldNode := ir.Get(node, "Suffix"); fieldNode != nil {
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("field %q: expected string, got %v", "Suffix", fieldNode.Type)
		}
		s.Suffix = fieldNode.String
	}

	// Field: DestDir
	if fieldNode := ir.Get(node, "DestDir"); fieldNode != nil {
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("field %q: expected string, got %v", "DestDir", fieldNode.Type)
		}
		s.DestDir = fieldNode.String
	}

	// Field: Sources
	if fieldNode := ir.Get(node, "Sources"); fieldNode != nil {
		if fieldNode.Type == ir.ArrayType {
			slice := make([]DirSource, len(fieldNode.Values))
			for i, v := range fieldNode.Values {
				elem := DirSource{}
				if err := elem.FromTony(v, opts...); err != nil {
					return fmt.Errorf("slice element %d: %w", i, err)
				}
				slice[i] = elem
			}
			s.Sources = slice
		}
	}

	// Field: Patches
	if fieldNode := ir.Get(node, "Patches"); fieldNode != nil {
		if fieldNode.Type == ir.ArrayType {
			slice := make([]DirPatch, len(fieldNode.Values))
			for i, v := range fieldNode.Values {
				elem := DirPatch{}
				if err := elem.FromTony(v, opts...); err != nil {
					return fmt.Errorf("slice element %d: %w", i, err)
				}
				slice[i] = elem
			}
			s.Patches = slice
		}
	}

	// Field: Env
	if fieldNode := ir.Get(node, "Env"); fieldNode != nil {
		if fieldNode.Type == ir.ObjectType {
			m := make(map[string]*ir.Node)
			irMap := ir.ToMap(fieldNode)
			for k, v := range irMap {
				m[k] = v
			}
			s.Env = m
		}
	}

	return nil
}

// ToTonyBytes converts Dir to a Tony IR node and encodes it to bytes.
func (s *Dir) ToTonyBytes(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTony(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTonyBytes parses data from bytes and populates Dir.
func (s *Dir) FromTonyBytes(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTony(node, opts...)
}

// ToTony converts DirSource to a Tony IR node.
func (s *DirSource) ToTony(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Format (optional)
	if s.Format != nil {
		if s.Format != nil {
			irMap["Format"] = ir.FromInt(int64(*s.Format))
		}
	}

	// Field: Exec (optional)
	if s.Exec != nil {
		if s.Exec != nil {
			irMap["Exec"] = ir.FromString(*s.Exec)
		}
	}

	// Field: Dir (optional)
	if s.Dir != nil {
		if s.Dir != nil {
			irMap["Dir"] = ir.FromString(*s.Dir)
		}
	}

	// Field: URL (optional)
	if s.URL != nil {
		if s.URL != nil {
			irMap["URL"] = ir.FromString(*s.URL)
		}
	}

	// Create IR node with schema tag
	node := ir.FromMap(irMap)
	node.Tag = "!dirsource"
	return node, nil
}

// FromTony populates DirSource from a Tony IR node.
func (s *DirSource) FromTony(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	// Field: Format
	if fieldNode := ir.Get(node, "Format"); fieldNode != nil {
		val := new(format.Format)
		if fieldNode.Int64 == nil {
			return fmt.Errorf("%s: expected number, got %v", "field \"Format\"", fieldNode.Type)
		}
		*val = format.Format(*fieldNode.Int64)
		s.Format = val
	}

	// Field: Exec
	if fieldNode := ir.Get(node, "Exec"); fieldNode != nil {
		val := new(string)
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("%s: expected string, got %v", "field \"Exec\"", fieldNode.Type)
		}
		*val = string(fieldNode.String)
		s.Exec = val
	}

	// Field: Dir
	if fieldNode := ir.Get(node, "Dir"); fieldNode != nil {
		val := new(string)
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("%s: expected string, got %v", "field \"Dir\"", fieldNode.Type)
		}
		*val = string(fieldNode.String)
		s.Dir = val
	}

	// Field: URL
	if fieldNode := ir.Get(node, "URL"); fieldNode != nil {
		val := new(string)
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("%s: expected string, got %v", "field \"URL\"", fieldNode.Type)
		}
		*val = string(fieldNode.String)
		s.URL = val
	}

	return nil
}

// ToTonyBytes converts DirSource to a Tony IR node and encodes it to bytes.
func (s *DirSource) ToTonyBytes(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTony(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTonyBytes parses data from bytes and populates DirSource.
func (s *DirSource) FromTonyBytes(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTony(node, opts...)
}

// ToTony converts DirPatch to a Tony IR node.
func (s *DirPatch) ToTony(opts ...encode.EncodeOption) (*ir.Node, error) {
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Match (optional)
	if s.Match != nil {
		irMap["Match"] = s.Match
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		irMap["Patch"] = s.Patch
	}

	// Field: File
	irMap["File"] = ir.FromString(s.File)

	// Field: If
	irMap["If"] = ir.FromString(s.If)

	// Create IR node with schema tag
	node := ir.FromMap(irMap)
	node.Tag = "!dirpatch"
	return node, nil
}

// FromTony populates DirPatch from a Tony IR node.
func (s *DirPatch) FromTony(node *ir.Node, opts ...parse.ParseOption) error {
	// Validate IR node type
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected object type, got %v", node.Type)
	}

	if fieldNode := ir.Get(node, "Match"); fieldNode != nil {
		s.Match = fieldNode
	}

	if fieldNode := ir.Get(node, "Patch"); fieldNode != nil {
		s.Patch = fieldNode
	}

	// Field: File
	if fieldNode := ir.Get(node, "File"); fieldNode != nil {
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("field %q: expected string, got %v", "File", fieldNode.Type)
		}
		s.File = fieldNode.String
	}

	// Field: If
	if fieldNode := ir.Get(node, "If"); fieldNode != nil {
		if fieldNode.Type != ir.StringType {
			return fmt.Errorf("field %q: expected string, got %v", "If", fieldNode.Type)
		}
		s.If = fieldNode.String
	}

	return nil
}

// ToTonyBytes converts DirPatch to a Tony IR node and encodes it to bytes.
func (s *DirPatch) ToTonyBytes(opts ...encode.EncodeOption) ([]byte, error) {
	node, err := s.ToTony(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, opts...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTonyBytes parses data from bytes and populates DirPatch.
func (s *DirPatch) FromTonyBytes(data []byte, opts ...parse.ParseOption) error {
	node, err := parse.Parse(data, opts...)
	if err != nil {
		return err
	}
	return s.FromTony(node, opts...)
}
