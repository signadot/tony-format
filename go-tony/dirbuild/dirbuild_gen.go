// Code generated by tony-codegen. DO NOT EDIT.

package dirbuild

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/format"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Dir to a Tony IR node.
func (s *Dir) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Suffix
	irMap["suffix"] = ir.FromString(s.Suffix)

	// Field: DestDir
	irMap["destDir"] = ir.FromString(s.DestDir)

	// Field: Sources
	if len(s.Sources) > 0 {
		slice := make([]*ir.Node, len(s.Sources))
		for i, v := range s.Sources {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["sources"] = ir.FromSlice(slice)
	}

	// Field: Patches
	if len(s.Patches) > 0 {
		slice := make([]*ir.Node, len(s.Patches))
		for i, v := range s.Patches {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["patches"] = ir.FromSlice(slice)
	}

	// Field: Env
	if len(s.Env) > 0 {
		mapNodes := make(map[string]*ir.Node)
		for k, v := range s.Env {
			mapNodes[k] = v
		}
		irMap["env"] = ir.FromMap(mapNodes)
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!dir"), nil
}

// FromTonyIR populates Dir from a Tony IR node.
func (s *Dir) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Dir, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "suffix":
			// Field: Suffix
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "suffix", fieldNode.Type)
			}
			s.Suffix = fieldNode.String
		case "destDir":
			// Field: DestDir
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "destDir", fieldNode.Type)
			}
			s.DestDir = fieldNode.String
		case "sources":
			// Field: Sources
			if fieldNode.Type == ir.ArrayType {
				slice := make([]DirSource, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := DirSource{}
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.Sources = slice
			}
		case "patches":
			// Field: Patches
			if fieldNode.Type == ir.ArrayType {
				slice := make([]DirPatch, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := DirPatch{}
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.Patches = slice
			}
		case "env":
			// Field: Env
			if fieldNode.Type == ir.ObjectType {
				m := make(map[string]*ir.Node)
				irMap := ir.ToMap(fieldNode)
				for k, v := range irMap {
					m[k] = v
				}
				s.Env = m
			}
		}
	}

	return nil
}

// ToTony converts Dir to Tony format bytes.
func (s *Dir) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Dir.
func (s *Dir) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DirSource to a Tony IR node.
func (s *DirSource) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Format (optional)
	if s.Format != nil {
		if s.Format != nil {
			irMap["format"] = ir.FromInt(int64(*s.Format))
		}
	}

	// Field: Exec (optional)
	if s.Exec != nil {
		if s.Exec != nil {
			irMap["exec"] = ir.FromString(*s.Exec)
		}
	}

	// Field: Dir (optional)
	if s.Dir != nil {
		if s.Dir != nil {
			irMap["dir"] = ir.FromString(*s.Dir)
		}
	}

	// Field: URL (optional)
	if s.URL != nil {
		if s.URL != nil {
			irMap["url"] = ir.FromString(*s.URL)
		}
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!dirsource"), nil
}

// FromTonyIR populates DirSource from a Tony IR node.
func (s *DirSource) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DirSource, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "format":
			// Field: Format
			val := new(format.Format)
			if fieldNode.Int64 == nil {
				return fmt.Errorf("%s: expected number, got %v", "field \"format\"", fieldNode.Type)
			}
			*val = format.Format(*fieldNode.Int64)
			s.Format = val
		case "exec":
			// Field: Exec
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"exec\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.Exec = val
		case "dir":
			// Field: Dir
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"dir\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.Dir = val
		case "url":
			// Field: URL
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"url\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.URL = val
		}
	}

	return nil
}

// ToTony converts DirSource to Tony format bytes.
func (s *DirSource) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DirSource.
func (s *DirSource) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DirPatch to a Tony IR node.
func (s *DirPatch) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Match (optional)
	if s.Match != nil {
		if s.Match == nil {
			irMap["match"] = ir.Null()
		} else {
			irMap["match"] = s.Match
		}
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		if s.Patch == nil {
			irMap["patch"] = ir.Null()
		} else {
			irMap["patch"] = s.Patch
		}
	}

	// Field: File
	irMap["file"] = ir.FromString(s.File)

	// Field: If
	irMap["if"] = ir.FromString(s.If)

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!dirpatch"), nil
}

// FromTonyIR populates DirPatch from a Tony IR node.
func (s *DirPatch) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DirPatch, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "match":
			s.Match = fieldNode
		case "patch":
			s.Patch = fieldNode
		case "file":
			// Field: File
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "file", fieldNode.Type)
			}
			s.File = fieldNode.String
		case "if":
			// Field: If
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "if", fieldNode.Type)
			}
			s.If = fieldNode.String
		}
	}

	return nil
}

// ToTony converts DirPatch to Tony format bytes.
func (s *DirPatch) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DirPatch.
func (s *DirPatch) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
