// Code generated by tony-codegen. DO NOT EDIT.

package issuelib

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Issue to a Tony IR node.
func (s *Issue) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ID
	irMap["id"] = ir.FromInt(int64(s.ID))

	// Field: Status
	irMap["status"] = ir.FromString(s.Status)

	// Field: Created
	if txt, err := s.Created.MarshalText(); err != nil {
		return nil, fmt.Errorf("failed to marshal field %q: %w", "Created", err)
	} else {
		irMap["created"] = ir.FromString(string(txt))
	}

	// Field: Updated
	if txt, err := s.Updated.MarshalText(); err != nil {
		return nil, fmt.Errorf("failed to marshal field %q: %w", "Updated", err)
	} else {
		irMap["updated"] = ir.FromString(string(txt))
	}

	// Field: Commits
	if len(s.Commits) > 0 {
		slice := make([]*ir.Node, len(s.Commits))
		for i, v := range s.Commits {
			slice[i] = ir.FromString(v)
		}
		irMap["commits"] = ir.FromSlice(slice)
	}

	// Field: Branches
	if len(s.Branches) > 0 {
		slice := make([]*ir.Node, len(s.Branches))
		for i, v := range s.Branches {
			slice[i] = ir.FromString(v)
		}
		irMap["branches"] = ir.FromSlice(slice)
	}

	// Field: ClosedBy (optional)
	if s.ClosedBy != nil {
		irMap["closed_by"] = ir.FromString(*s.ClosedBy)
	}

	// Field: RelatedIssues
	if len(s.RelatedIssues) > 0 {
		slice := make([]*ir.Node, len(s.RelatedIssues))
		for i, v := range s.RelatedIssues {
			slice[i] = ir.FromString(v)
		}
		irMap["related_issues"] = ir.FromSlice(slice)
	}

	// Field: Blocks
	if len(s.Blocks) > 0 {
		slice := make([]*ir.Node, len(s.Blocks))
		for i, v := range s.Blocks {
			slice[i] = ir.FromString(v)
		}
		irMap["blocks"] = ir.FromSlice(slice)
	}

	// Field: BlockedBy
	if len(s.BlockedBy) > 0 {
		slice := make([]*ir.Node, len(s.BlockedBy))
		for i, v := range s.BlockedBy {
			slice[i] = ir.FromString(v)
		}
		irMap["blocked_by"] = ir.FromSlice(slice)
	}

	// Field: Duplicates
	if len(s.Duplicates) > 0 {
		slice := make([]*ir.Node, len(s.Duplicates))
		for i, v := range s.Duplicates {
			slice[i] = ir.FromString(v)
		}
		irMap["duplicates"] = ir.FromSlice(slice)
	}

	// Field: Labels
	if len(s.Labels) > 0 {
		slice := make([]*ir.Node, len(s.Labels))
		for i, v := range s.Labels {
			slice[i] = ir.FromString(v)
		}
		irMap["labels"] = ir.FromSlice(slice)
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!issue"), nil
}

// FromTonyIR populates Issue from a Tony IR node.
func (s *Issue) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Issue, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "id":
			// Field: ID
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "id", fieldNode.Type)
			}
			s.ID = int64(*fieldNode.Int64)
		case "status":
			// Field: Status
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "status", fieldNode.Type)
			}
			s.Status = fieldNode.String
		case "created":
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string for TextUnmarshaler, got %v", "created", fieldNode.Type)
			}
			if err := s.Created.UnmarshalText([]byte(fieldNode.String)); err != nil {
				return fmt.Errorf("field %q: failed to unmarshal text: %w", "created", err)
			}
		case "updated":
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string for TextUnmarshaler, got %v", "updated", fieldNode.Type)
			}
			if err := s.Updated.UnmarshalText([]byte(fieldNode.String)); err != nil {
				return fmt.Errorf("field %q: failed to unmarshal text: %w", "updated", err)
			}
		case "commits":
			// Field: Commits
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.Commits = slice
			}
		case "branches":
			// Field: Branches
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.Branches = slice
			}
		case "closed_by":
			// Field: ClosedBy
			if fieldNode.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNode.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"closed_by\"", fieldNode.Type)
				}
				*val = string(fieldNode.String)
				s.ClosedBy = val
			}
		case "related_issues":
			// Field: RelatedIssues
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.RelatedIssues = slice
			}
		case "blocks":
			// Field: Blocks
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.Blocks = slice
			}
		case "blocked_by":
			// Field: BlockedBy
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.BlockedBy = slice
			}
		case "duplicates":
			// Field: Duplicates
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.Duplicates = slice
			}
		case "labels":
			// Field: Labels
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.Labels = slice
			}
		}
	}

	return nil
}

// ToTony converts Issue to Tony format bytes.
func (s *Issue) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Issue.
func (s *Issue) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
