// Code generated by tony-codegen. DO NOT EDIT.

package server

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
	"time"
)

// ToTonyIR converts Config to a Tony IR node.
func (s *Config) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Schema (optional)
	if s.Schema != nil {
		irMap["schema"] = s.Schema
	}

	// Field: Snapshot (optional)
	if s.Snapshot != nil {
		node, err = s.Snapshot.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["snapshot"] = node
	}

	// Field: Tx (optional)
	if s.Tx != nil {
		node, err = s.Tx.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["tx"] = node
	}

	return ir.FromMap(irMap).WithTag("!config"), nil
}

// FromTonyIR populates Config from a Tony IR node.
func (s *Config) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Config, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "schema":
			if gomap.GetUnmapComments(opts...) {
				s.Schema = fieldNode
			} else {
				s.Schema = fieldNodeUnwrapped
			}
		case "snapshot":
			// Field: Snapshot
			s.Snapshot = &SnapshotConfig{}
			if err := s.Snapshot.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "tx":
			// Field: Tx
			s.Tx = &TxConfig{}
			if err := s.Tx.FromTonyIR(fieldNode); err != nil {
				return err
			}
		}
	}

	return nil
}

// ToTony converts Config to Tony format bytes.
func (s *Config) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Config.
func (s *Config) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts TxConfig to a Tony IR node.
func (s *TxConfig) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Timeout
	irMap["timeout"] = ir.FromInt(int64(s.Timeout))

	return ir.FromMap(irMap).WithTag("!tx-config"), nil
}

// FromTonyIR populates TxConfig from a Tony IR node.
func (s *TxConfig) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for TxConfig, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "timeout":
			// Field: Timeout
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "timeout", fieldNodeUnwrapped.Type)
			}
			s.Timeout = time.Duration(*fieldNodeUnwrapped.Int64)
		}
	}

	return nil
}

// ToTony converts TxConfig to Tony format bytes.
func (s *TxConfig) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates TxConfig.
func (s *TxConfig) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts SnapshotConfig to a Tony IR node.
func (s *SnapshotConfig) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: MaxCommits
	irMap["maxCommits"] = ir.FromInt(int64(s.MaxCommits))

	// Field: MaxBytes
	irMap["maxBytes"] = ir.FromInt(int64(s.MaxBytes))

	return ir.FromMap(irMap).WithTag("!snapshot-config"), nil
}

// FromTonyIR populates SnapshotConfig from a Tony IR node.
func (s *SnapshotConfig) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for SnapshotConfig, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "maxCommits":
			// Field: MaxCommits
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "maxCommits", fieldNodeUnwrapped.Type)
			}
			s.MaxCommits = int64(*fieldNodeUnwrapped.Int64)
		case "maxBytes":
			// Field: MaxBytes
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "maxBytes", fieldNodeUnwrapped.Type)
			}
			s.MaxBytes = int64(*fieldNodeUnwrapped.Int64)
		}
	}

	return nil
}

// ToTony converts SnapshotConfig to Tony format bytes.
func (s *SnapshotConfig) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates SnapshotConfig.
func (s *SnapshotConfig) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
