// Code generated by tony-codegen. DO NOT EDIT.

package tx

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
	"github.com/signadot/tony-format/go-tony/system/logd/api"
	"time"
)

// ToTonyIR converts State to a Tony IR node.
func (s *State) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: TxID
	irMap["TxID"] = ir.FromInt(int64(s.TxID))

	// Field: CreatedAt
	if txt, err := s.CreatedAt.MarshalText(); err != nil {
		return nil, fmt.Errorf("failed to marshal field %q: %w", "CreatedAt", err)
	} else {
		irMap["CreatedAt"] = ir.FromString(string(txt))
	}

	// Field: Timeout
	irMap["Timeout"] = ir.FromInt(int64(s.Timeout))

	// Field: Scope (optional)
	if s.Scope != nil {
		irMap["Scope"] = ir.FromString(*s.Scope)
	}

	// Field: PatcherData
	if len(s.PatcherData) > 0 {
		slice := make([]*ir.Node, len(s.PatcherData))
		for i, v := range s.PatcherData {
			node, err = v.ToTonyIR()
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["PatcherData"] = ir.FromSlice(slice)
	}

	return ir.FromMap(irMap).WithTag("!tx-state"), nil
}

// FromTonyIR populates State from a Tony IR node.
func (s *State) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for State, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "TxID":
			// Field: TxID
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "TxID", fieldNodeUnwrapped.Type)
			}
			s.TxID = int64(*fieldNodeUnwrapped.Int64)
		case "CreatedAt":
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string for TextUnmarshaler, got %v", "CreatedAt", fieldNodeUnwrapped.Type)
			}
			if err := s.CreatedAt.UnmarshalText([]byte(fieldNodeUnwrapped.String)); err != nil {
				return fmt.Errorf("field %q: failed to unmarshal text: %w", "CreatedAt", err)
			}
		case "Timeout":
			// Field: Timeout
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "Timeout", fieldNodeUnwrapped.Type)
			}
			s.Timeout = time.Duration(*fieldNodeUnwrapped.Int64)
		case "Scope":
			// Field: Scope
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"Scope\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.Scope = val
			}
		case "PatcherData":
			// Field: PatcherData
			if fieldNodeUnwrapped.Type == ir.ArrayType {
				slice := make([]*PatcherData, len(fieldNodeUnwrapped.Values))
				for i, v := range fieldNodeUnwrapped.Values {
					elem := new(PatcherData)
					if err := elem.FromTonyIR(v); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.PatcherData = slice
			}
		}
	}

	return nil
}

// ToTony converts State to Tony format bytes.
func (s *State) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates State.
func (s *State) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts PatcherData to a Tony IR node.
func (s *PatcherData) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ReceivedAt
	if txt, err := s.ReceivedAt.MarshalText(); err != nil {
		return nil, fmt.Errorf("failed to marshal field %q: %w", "ReceivedAt", err)
	} else {
		irMap["ReceivedAt"] = ir.FromString(string(txt))
	}

	// Field: API (optional)
	if s.API != nil {
		node, err = s.API.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["API"] = node
	}

	return ir.FromMap(irMap).WithTag("!patcher-data"), nil
}

// FromTonyIR populates PatcherData from a Tony IR node.
func (s *PatcherData) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for PatcherData, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "ReceivedAt":
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string for TextUnmarshaler, got %v", "ReceivedAt", fieldNodeUnwrapped.Type)
			}
			if err := s.ReceivedAt.UnmarshalText([]byte(fieldNodeUnwrapped.String)); err != nil {
				return fmt.Errorf("field %q: failed to unmarshal text: %w", "ReceivedAt", err)
			}
		case "API":
			// Field: API
			s.API = &api.Patch{}
			if err := s.API.FromTonyIR(fieldNode); err != nil {
				return err
			}
		}
	}

	return nil
}

// ToTony converts PatcherData to Tony format bytes.
func (s *PatcherData) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates PatcherData.
func (s *PatcherData) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
