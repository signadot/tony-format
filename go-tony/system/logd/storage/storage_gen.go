// Code generated by tony-codegen. DO NOT EDIT.

package storage

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
	"github.com/signadot/tony-format/go-tony/system/logd/api"
)

// ToTonyIR converts TxLogEntry to a Tony IR node.
func (s *TxLogEntry) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Commit
	irMap["Commit"] = ir.FromInt(int64(s.Commit))

	// Field: TxID
	irMap["TxID"] = ir.FromInt(int64(s.TxID))

	// Field: Timestamp
	irMap["Timestamp"] = ir.FromString(s.Timestamp)

	// Field: PendingFiles
	if len(s.PendingFiles) > 0 {
		slice := make([]*ir.Node, len(s.PendingFiles))
		for i, v := range s.PendingFiles {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["PendingFiles"] = ir.FromSlice(slice)
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!txlog-entry"), nil
}

// FromTonyIR populates TxLogEntry from a Tony IR node.
func (s *TxLogEntry) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for TxLogEntry, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "Commit":
			// Field: Commit
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "Commit", fieldNode.Type)
			}
			s.Commit = int64(*fieldNode.Int64)
		case "TxID":
			// Field: TxID
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "TxID", fieldNode.Type)
			}
			s.TxID = int64(*fieldNode.Int64)
		case "Timestamp":
			// Field: Timestamp
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "Timestamp", fieldNode.Type)
			}
			s.Timestamp = fieldNode.String
		case "PendingFiles":
			// Field: PendingFiles
			if fieldNode.Type == ir.ArrayType {
				slice := make([]FileRef, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := FileRef{}
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.PendingFiles = slice
			}
		}
	}

	return nil
}

// ToTony converts TxLogEntry to Tony format bytes.
func (s *TxLogEntry) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates TxLogEntry.
func (s *TxLogEntry) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts FileRef to a Tony IR node.
func (s *FileRef) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: VirtualPath
	irMap["VirtualPath"] = ir.FromString(s.VirtualPath)

	// Field: TxSeq
	irMap["TxSeq"] = ir.FromInt(int64(s.TxSeq))

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!pending-file-ref"), nil
}

// FromTonyIR populates FileRef from a Tony IR node.
func (s *FileRef) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for FileRef, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "VirtualPath":
			// Field: VirtualPath
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "VirtualPath", fieldNode.Type)
			}
			s.VirtualPath = fieldNode.String
		case "TxSeq":
			// Field: TxSeq
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "TxSeq", fieldNode.Type)
			}
			s.TxSeq = int64(*fieldNode.Int64)
		}
	}

	return nil
}

// ToTony converts FileRef to Tony format bytes.
func (s *FileRef) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates FileRef.
func (s *FileRef) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts TxState to a Tony IR node.
func (s *TxState) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: TxID
	irMap["TxID"] = ir.FromInt(int64(s.TxID))

	// Field: ParticipantCount
	irMap["ParticipantCount"] = ir.FromInt(int64(s.ParticipantCount))

	// Field: ParticipantRequests
	if len(s.ParticipantRequests) > 0 {
		slice := make([]*ir.Node, len(s.ParticipantRequests))
		for i, v := range s.ParticipantRequests {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["ParticipantRequests"] = ir.FromSlice(slice)
	}

	// Field: ParticipantMatches
	if len(s.ParticipantMatches) > 0 {
		slice := make([]*ir.Node, len(s.ParticipantMatches))
		for i, v := range s.ParticipantMatches {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["ParticipantMatches"] = ir.FromSlice(slice)
	}

	// Field: ParticipantsReceived
	irMap["ParticipantsReceived"] = ir.FromInt(int64(s.ParticipantsReceived))

	// Field: Status
	irMap["Status"] = ir.FromString(s.Status)

	// Field: CreatedAt
	irMap["CreatedAt"] = ir.FromString(s.CreatedAt)

	// Field: ExpiresAt
	irMap["ExpiresAt"] = ir.FromString(s.ExpiresAt)

	// Field: FileMetas
	if len(s.FileMetas) > 0 {
		slice := make([]*ir.Node, len(s.FileMetas))
		for i, v := range s.FileMetas {
			node, err = v.ToTonyIR(opts...)
			if err != nil {
				return nil, fmt.Errorf("failed to convert slice element %d: %w", i, err)
			}
			slice[i] = node
		}
		irMap["FileMetas"] = ir.FromSlice(slice)
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!transaction-state"), nil
}

// FromTonyIR populates TxState from a Tony IR node.
func (s *TxState) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for TxState, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "TxID":
			// Field: TxID
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "TxID", fieldNode.Type)
			}
			s.TxID = int64(*fieldNode.Int64)
		case "ParticipantCount":
			// Field: ParticipantCount
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "ParticipantCount", fieldNode.Type)
			}
			s.ParticipantCount = int(*fieldNode.Int64)
		case "ParticipantRequests":
			// Field: ParticipantRequests
			if fieldNode.Type == ir.ArrayType {
				slice := make([]*api.Patch, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := new(api.Patch)
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.ParticipantRequests = slice
			}
		case "ParticipantMatches":
			// Field: ParticipantMatches
			if fieldNode.Type == ir.ArrayType {
				slice := make([]*api.Match, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := new(api.Match)
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.ParticipantMatches = slice
			}
		case "ParticipantsReceived":
			// Field: ParticipantsReceived
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "ParticipantsReceived", fieldNode.Type)
			}
			s.ParticipantsReceived = int(*fieldNode.Int64)
		case "Status":
			// Field: Status
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "Status", fieldNode.Type)
			}
			s.Status = fieldNode.String
		case "CreatedAt":
			// Field: CreatedAt
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "CreatedAt", fieldNode.Type)
			}
			s.CreatedAt = fieldNode.String
		case "ExpiresAt":
			// Field: ExpiresAt
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "ExpiresAt", fieldNode.Type)
			}
			s.ExpiresAt = fieldNode.String
		case "FileMetas":
			// Field: FileMetas
			if fieldNode.Type == ir.ArrayType {
				slice := make([]FileMeta, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					elem := FileMeta{}
					if err := elem.FromTonyIR(v, opts...); err != nil {
						return fmt.Errorf("failed to convert slice element %d: %w", i, err)
					}
					slice[i] = elem
				}
				s.FileMetas = slice
			}
		}
	}

	return nil
}

// ToTony converts TxState to Tony format bytes.
func (s *TxState) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates TxState.
func (s *TxState) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts FileMeta to a Tony IR node.
func (s *FileMeta) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Path
	irMap["Path"] = ir.FromString(s.Path)

	// Field: FSPath
	irMap["FSPath"] = ir.FromString(s.FSPath)

	// Field: WrittenAt
	irMap["WrittenAt"] = ir.FromString(s.WrittenAt)

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!pending-diff"), nil
}

// FromTonyIR populates FileMeta from a Tony IR node.
func (s *FileMeta) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for FileMeta, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "Path":
			// Field: Path
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "Path", fieldNode.Type)
			}
			s.Path = fieldNode.String
		case "FSPath":
			// Field: FSPath
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "FSPath", fieldNode.Type)
			}
			s.FSPath = fieldNode.String
		case "WrittenAt":
			// Field: WrittenAt
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "WrittenAt", fieldNode.Type)
			}
			s.WrittenAt = fieldNode.String
		}
	}

	return nil
}

// ToTony converts FileMeta to Tony format bytes.
func (s *FileMeta) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates FileMeta.
func (s *FileMeta) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
