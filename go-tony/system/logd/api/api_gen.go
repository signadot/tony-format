// Code generated by tony-codegen. DO NOT EDIT.

package api

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Body to a Tony IR node.
func (s *Body) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	// Field: Match (optional)
	if s.Match != nil {
		if s.Match == nil {
			irMap["match"] = ir.Null()
		} else {
			irMap["match"] = s.Match
		}
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		if s.Patch == nil {
			irMap["patch"] = ir.Null()
		} else {
			irMap["patch"] = s.Patch
		}
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!body"), nil
}

// FromTonyIR populates Body from a Tony IR node.
func (s *Body) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Body, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "path":
			// Field: Path
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNode.Type)
			}
			s.Path = fieldNode.String
		case "match":
			s.Match = fieldNode
		case "patch":
			s.Patch = fieldNode
		}
	}

	return nil
}

// ToTony converts Body to Tony format bytes.
func (s *Body) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Body.
func (s *Body) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts EncodingOptions to a Tony IR node.
func (s *EncodingOptions) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Wire
	irMap["wire"] = ir.FromBool(s.Wire)

	// Field: Brackets
	irMap["brackets"] = ir.FromBool(s.Brackets)

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!encoding-options"), nil
}

// FromTonyIR populates EncodingOptions from a Tony IR node.
func (s *EncodingOptions) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for EncodingOptions, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "wire":
			// Field: Wire
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "wire", fieldNode.Type)
			}
			s.Wire = fieldNode.Bool
		case "brackets":
			// Field: Brackets
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "brackets", fieldNode.Type)
			}
			s.Brackets = fieldNode.Bool
		}
	}

	return nil
}

// ToTony converts EncodingOptions to Tony format bytes.
func (s *EncodingOptions) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates EncodingOptions.
func (s *EncodingOptions) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts MatchMeta to a Tony IR node.
func (s *MatchMeta) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Wire
	irMap["wire"] = ir.FromBool(s.Wire)

	// Field: Brackets
	irMap["brackets"] = ir.FromBool(s.Brackets)

	// Field: SeqID (optional)
	if s.SeqID != nil {
		if s.SeqID != nil {
			irMap["seq"] = ir.FromInt(int64(*s.SeqID))
		}
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!match-meta"), nil
}

// FromTonyIR populates MatchMeta from a Tony IR node.
func (s *MatchMeta) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for MatchMeta, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "wire":
			// Field: Wire
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "wire", fieldNode.Type)
			}
			s.Wire = fieldNode.Bool
		case "brackets":
			// Field: Brackets
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "brackets", fieldNode.Type)
			}
			s.Brackets = fieldNode.Bool
		case "seq":
			// Field: SeqID
			val := new(int64)
			if fieldNode.Int64 == nil {
				return fmt.Errorf("%s: expected number, got %v", "field \"seq\"", fieldNode.Type)
			}
			*val = int64(*fieldNode.Int64)
			s.SeqID = val
		}
	}

	return nil
}

// ToTony converts MatchMeta to Tony format bytes.
func (s *MatchMeta) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates MatchMeta.
func (s *MatchMeta) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Match to a Tony IR node.
func (s *Match) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Meta
	node, err = s.Meta.ToTonyIR(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Meta", err)
	}
	irMap["meta"] = node

	// Field: Body
	node, err = s.Body.ToTonyIR(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Body", err)
	}
	irMap["body"] = node

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!match"), nil
}

// FromTonyIR populates Match from a Tony IR node.
func (s *Match) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Match, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "meta":
			// Field: Meta
			if err := s.Meta.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "meta", err)
			}
		case "body":
			// Field: Body
			if err := s.Body.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "body", err)
			}
		}
	}

	return nil
}

// ToTony converts Match to Tony format bytes.
func (s *Match) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Match.
func (s *Match) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts PatchMeta to a Tony IR node.
func (s *PatchMeta) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Wire
	irMap["wire"] = ir.FromBool(s.Wire)

	// Field: Brackets
	irMap["brackets"] = ir.FromBool(s.Brackets)

	// Field: Tx (optional)
	if s.Tx != nil {
		if s.Tx != nil {
			irMap["tx"] = ir.FromString(*s.Tx)
		}
	}

	// Field: MaxDuration
	irMap["maxDuration"] = ir.FromString(s.MaxDuration)

	// Field: Seq (optional)
	if s.Seq != nil {
		if s.Seq != nil {
			irMap["seq"] = ir.FromInt(int64(*s.Seq))
		}
	}

	// Field: When
	irMap["when"] = ir.FromString(s.When)

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!patch-meta"), nil
}

// FromTonyIR populates PatchMeta from a Tony IR node.
func (s *PatchMeta) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for PatchMeta, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "wire":
			// Field: Wire
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "wire", fieldNode.Type)
			}
			s.Wire = fieldNode.Bool
		case "brackets":
			// Field: Brackets
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "brackets", fieldNode.Type)
			}
			s.Brackets = fieldNode.Bool
		case "tx":
			// Field: Tx
			val := new(string)
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("%s: expected string, got %v", "field \"tx\"", fieldNode.Type)
			}
			*val = string(fieldNode.String)
			s.Tx = val
		case "maxDuration":
			// Field: MaxDuration
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "maxDuration", fieldNode.Type)
			}
			s.MaxDuration = fieldNode.String
		case "seq":
			// Field: Seq
			val := new(int64)
			if fieldNode.Int64 == nil {
				return fmt.Errorf("%s: expected number, got %v", "field \"seq\"", fieldNode.Type)
			}
			*val = int64(*fieldNode.Int64)
			s.Seq = val
		case "when":
			// Field: When
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "when", fieldNode.Type)
			}
			s.When = fieldNode.String
		}
	}

	return nil
}

// ToTony converts PatchMeta to Tony format bytes.
func (s *PatchMeta) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates PatchMeta.
func (s *PatchMeta) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Patch to a Tony IR node.
func (s *Patch) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Meta
	node, err = s.Meta.ToTonyIR(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Meta", err)
	}
	irMap["meta"] = node

	// Field: Body
	node, err = s.Body.ToTonyIR(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Body", err)
	}
	irMap["body"] = node

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!patch"), nil
}

// FromTonyIR populates Patch from a Tony IR node.
func (s *Patch) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Patch, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "meta":
			// Field: Meta
			if err := s.Meta.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "meta", err)
			}
		case "body":
			// Field: Body
			if err := s.Body.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "body", err)
			}
		}
	}

	return nil
}

// ToTony converts Patch to Tony format bytes.
func (s *Patch) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Patch.
func (s *Patch) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts WatchMeta to a Tony IR node.
func (s *WatchMeta) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Wire
	irMap["wire"] = ir.FromBool(s.Wire)

	// Field: Brackets
	irMap["brackets"] = ir.FromBool(s.Brackets)

	// Field: From (optional)
	if s.From != nil {
		if s.From != nil {
			irMap["from"] = ir.FromInt(int64(*s.From))
		}
	}

	// Field: To (optional)
	if s.To != nil {
		if s.To != nil {
			irMap["to"] = ir.FromInt(int64(*s.To))
		}
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!watch-meta"), nil
}

// FromTonyIR populates WatchMeta from a Tony IR node.
func (s *WatchMeta) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for WatchMeta, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "wire":
			// Field: Wire
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "wire", fieldNode.Type)
			}
			s.Wire = fieldNode.Bool
		case "brackets":
			// Field: Brackets
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "brackets", fieldNode.Type)
			}
			s.Brackets = fieldNode.Bool
		case "from":
			// Field: From
			val := new(int64)
			if fieldNode.Int64 == nil {
				return fmt.Errorf("%s: expected number, got %v", "field \"from\"", fieldNode.Type)
			}
			*val = int64(*fieldNode.Int64)
			s.From = val
		case "to":
			// Field: To
			val := new(int64)
			if fieldNode.Int64 == nil {
				return fmt.Errorf("%s: expected number, got %v", "field \"to\"", fieldNode.Type)
			}
			*val = int64(*fieldNode.Int64)
			s.To = val
		}
	}

	return nil
}

// ToTony converts WatchMeta to Tony format bytes.
func (s *WatchMeta) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates WatchMeta.
func (s *WatchMeta) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Error to a Tony IR node.
func (s *Error) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Use TextMarshaler implementation
	txt, err := s.MarshalText()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal Error: %w", err)
	}
	return ir.FromString(string(txt)).WithTag("!error"), nil
}

// FromTonyIR populates Error from a Tony IR node.
func (s *Error) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	// Use TextUnmarshaler implementation
	if node.Type != ir.StringType {
		return fmt.Errorf("expected string for Error, got %v", node.Type)
	}
	if err := s.UnmarshalText([]byte(node.String)); err != nil {
		return fmt.Errorf("failed to unmarshal Error: %w", err)
	}
	return nil
}

// ToTony converts Error to Tony format bytes.
func (s *Error) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Error.
func (s *Error) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
