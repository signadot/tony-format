// Code generated by tony-codegen. DO NOT EDIT.

package api

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts PathData to a Tony IR node.
func (s *PathData) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	// Field: Data (optional)
	if s.Data != nil {
		irMap["data"] = s.Data
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates PathData from a Tony IR node.
func (s *PathData) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for PathData, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "path":
			// Field: Path
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNodeUnwrapped.Type)
			}
			s.Path = fieldNodeUnwrapped.String
		case "data":
			if gomap.GetUnmapComments(opts...) {
				s.Data = fieldNode
			} else {
				s.Data = fieldNodeUnwrapped
			}
		}
	}

	return nil
}

// ToTony converts PathData to Tony format bytes.
func (s *PathData) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates PathData.
func (s *PathData) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Patch to a Tony IR node.
func (s *Patch) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Match (optional)
	if s.Match != nil {
		node, err = s.Match.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["match"] = node
	}

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	// Field: Data (optional)
	if s.Data != nil {
		irMap["data"] = s.Data
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates Patch from a Tony IR node.
func (s *Patch) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Patch, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "match":
			// Field: Match
			s.Match = &PathData{}
			if err := s.Match.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "path":
			// Field: Path
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNodeUnwrapped.Type)
			}
			s.Path = fieldNodeUnwrapped.String
		case "data":
			if gomap.GetUnmapComments(opts...) {
				s.Data = fieldNode
			} else {
				s.Data = fieldNodeUnwrapped
			}
		}
	}

	return nil
}

// ToTony converts Patch to Tony format bytes.
func (s *Patch) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Patch.
func (s *Patch) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Error to a Tony IR node.
func (s *Error) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Use TextMarshaler implementation
	txt, err := s.MarshalText()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal Error: %w", err)
	}
	return ir.FromString(string(txt)), nil
}

// FromTonyIR populates Error from a Tony IR node.
func (s *Error) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	// Use TextUnmarshaler implementation
	if node.Type != ir.StringType {
		return fmt.Errorf("expected string for Error, got %v", node.Type)
	}
	if err := s.UnmarshalText([]byte(node.String)); err != nil {
		return fmt.Errorf("failed to unmarshal Error: %w", err)
	}
	return nil
}

// ToTony converts Error to Tony format bytes.
func (s *Error) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Error.
func (s *Error) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts Hello to a Tony IR node.
func (s *Hello) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ClientID
	irMap["clientId"] = ir.FromString(s.ClientID)

	// Field: Scope (optional)
	if s.Scope != nil {
		irMap["scope"] = ir.FromString(*s.Scope)
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates Hello from a Tony IR node.
func (s *Hello) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Hello, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "clientId":
			// Field: ClientID
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "clientId", fieldNodeUnwrapped.Type)
			}
			s.ClientID = fieldNodeUnwrapped.String
		case "scope":
			// Field: Scope
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"scope\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.Scope = val
			}
		}
	}

	return nil
}

// ToTony converts Hello to Tony format bytes.
func (s *Hello) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Hello.
func (s *Hello) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts HelloResponse to a Tony IR node.
func (s *HelloResponse) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ServerID
	irMap["serverId"] = ir.FromString(s.ServerID)

	// Field: Schema (optional)
	if s.Schema != nil {
		irMap["schema"] = s.Schema
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates HelloResponse from a Tony IR node.
func (s *HelloResponse) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for HelloResponse, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "serverId":
			// Field: ServerID
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "serverId", fieldNodeUnwrapped.Type)
			}
			s.ServerID = fieldNodeUnwrapped.String
		case "schema":
			if gomap.GetUnmapComments(opts...) {
				s.Schema = fieldNode
			} else {
				s.Schema = fieldNodeUnwrapped
			}
		}
	}

	return nil
}

// ToTony converts HelloResponse to Tony format bytes.
func (s *HelloResponse) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates HelloResponse.
func (s *HelloResponse) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts MatchRequest to a Tony IR node.
func (s *MatchRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Body
	node, err = s.Body.ToTonyIR()
	if err != nil {
		return nil, fmt.Errorf("failed to convert field %q: %w", "Body", err)
	}
	irMap["body"] = node

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates MatchRequest from a Tony IR node.
func (s *MatchRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for MatchRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "body":
			// Field: Body
			if err := s.Body.FromTonyIR(fieldNode); err != nil {
				return fmt.Errorf("field %q: %w", "body", err)
			}
		}
	}

	return nil
}

// ToTony converts MatchRequest to Tony format bytes.
func (s *MatchRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates MatchRequest.
func (s *MatchRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts PatchRequest to a Tony IR node.
func (s *PatchRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: TxID (optional)
	if s.TxID != nil {
		irMap["txId"] = ir.FromInt(int64(*s.TxID))
	}

	// Field: Timeout (optional)
	if s.Timeout != nil {
		irMap["timeout"] = ir.FromString(*s.Timeout)
	}

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	// Field: Data (optional)
	if s.Data != nil {
		irMap["data"] = s.Data
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates PatchRequest from a Tony IR node.
func (s *PatchRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for PatchRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "txId":
			// Field: TxID
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(int64)
				if fieldNodeUnwrapped.Int64 == nil {
					return fmt.Errorf("%s: expected number, got %v", "field \"txId\"", fieldNodeUnwrapped.Type)
				}
				*val = int64(*fieldNodeUnwrapped.Int64)
				s.TxID = val
			}
		case "timeout":
			// Field: Timeout
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"timeout\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.Timeout = val
			}
		case "path":
			// Field: Path
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNodeUnwrapped.Type)
			}
			s.Path = fieldNodeUnwrapped.String
		case "data":
			if gomap.GetUnmapComments(opts...) {
				s.Data = fieldNode
			} else {
				s.Data = fieldNodeUnwrapped
			}
		}
	}

	return nil
}

// ToTony converts PatchRequest to Tony format bytes.
func (s *PatchRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates PatchRequest.
func (s *PatchRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts NewTxRequest to a Tony IR node.
func (s *NewTxRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Participants
	irMap["participants"] = ir.FromInt(int64(s.Participants))

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates NewTxRequest from a Tony IR node.
func (s *NewTxRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for NewTxRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "participants":
			// Field: Participants
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "participants", fieldNodeUnwrapped.Type)
			}
			s.Participants = int(*fieldNodeUnwrapped.Int64)
		}
	}

	return nil
}

// ToTony converts NewTxRequest to Tony format bytes.
func (s *NewTxRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates NewTxRequest.
func (s *NewTxRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts WatchRequest to a Tony IR node.
func (s *WatchRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	// Field: FromCommit (optional)
	if s.FromCommit != nil {
		irMap["fromCommit"] = ir.FromInt(int64(*s.FromCommit))
	}

	// Field: NoInit
	irMap["noInit"] = ir.FromBool(s.NoInit)

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates WatchRequest from a Tony IR node.
func (s *WatchRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for WatchRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "path":
			// Field: Path
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNodeUnwrapped.Type)
			}
			s.Path = fieldNodeUnwrapped.String
		case "fromCommit":
			// Field: FromCommit
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(int64)
				if fieldNodeUnwrapped.Int64 == nil {
					return fmt.Errorf("%s: expected number, got %v", "field \"fromCommit\"", fieldNodeUnwrapped.Type)
				}
				*val = int64(*fieldNodeUnwrapped.Int64)
				s.FromCommit = val
			}
		case "noInit":
			// Field: NoInit
			if fieldNodeUnwrapped.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "noInit", fieldNodeUnwrapped.Type)
			}
			s.NoInit = fieldNodeUnwrapped.Bool
		}
	}

	return nil
}

// ToTony converts WatchRequest to Tony format bytes.
func (s *WatchRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates WatchRequest.
func (s *WatchRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts UnwatchRequest to a Tony IR node.
func (s *UnwatchRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates UnwatchRequest from a Tony IR node.
func (s *UnwatchRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for UnwatchRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "path":
			// Field: Path
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNodeUnwrapped.Type)
			}
			s.Path = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts UnwatchRequest to Tony format bytes.
func (s *UnwatchRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates UnwatchRequest.
func (s *UnwatchRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DeleteScopeRequest to a Tony IR node.
func (s *DeleteScopeRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ScopeID
	irMap["scopeId"] = ir.FromString(s.ScopeID)

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates DeleteScopeRequest from a Tony IR node.
func (s *DeleteScopeRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DeleteScopeRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "scopeId":
			// Field: ScopeID
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "scopeId", fieldNodeUnwrapped.Type)
			}
			s.ScopeID = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts DeleteScopeRequest to Tony format bytes.
func (s *DeleteScopeRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DeleteScopeRequest.
func (s *DeleteScopeRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts SessionRequest to a Tony IR node.
func (s *SessionRequest) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ID (optional)
	if s.ID != nil {
		irMap["id"] = ir.FromString(*s.ID)
	}

	// Field: Hello (optional)
	if s.Hello != nil {
		node, err = s.Hello.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["hello"] = node
	}

	// Field: Match (optional)
	if s.Match != nil {
		node, err = s.Match.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["match"] = node
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		node, err = s.Patch.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["patch"] = node
	}

	// Field: NewTx (optional)
	if s.NewTx != nil {
		node, err = s.NewTx.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["newtx"] = node
	}

	// Field: Watch (optional)
	if s.Watch != nil {
		node, err = s.Watch.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["watch"] = node
	}

	// Field: Unwatch (optional)
	if s.Unwatch != nil {
		node, err = s.Unwatch.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["unwatch"] = node
	}

	// Field: DeleteScope (optional)
	if s.DeleteScope != nil {
		node, err = s.DeleteScope.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["deleteScope"] = node
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates SessionRequest from a Tony IR node.
func (s *SessionRequest) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for SessionRequest, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "id":
			// Field: ID
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"id\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.ID = val
			}
		case "hello":
			// Field: Hello
			s.Hello = &Hello{}
			if err := s.Hello.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "match":
			// Field: Match
			s.Match = &MatchRequest{}
			if err := s.Match.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "patch":
			// Field: Patch
			s.Patch = &PatchRequest{}
			if err := s.Patch.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "newtx":
			// Field: NewTx
			s.NewTx = &NewTxRequest{}
			if err := s.NewTx.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "watch":
			// Field: Watch
			s.Watch = &WatchRequest{}
			if err := s.Watch.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "unwatch":
			// Field: Unwatch
			s.Unwatch = &UnwatchRequest{}
			if err := s.Unwatch.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "deleteScope":
			// Field: DeleteScope
			s.DeleteScope = &DeleteScopeRequest{}
			if err := s.DeleteScope.FromTonyIR(fieldNode); err != nil {
				return err
			}
		}
	}

	return nil
}

// ToTony converts SessionRequest to Tony format bytes.
func (s *SessionRequest) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates SessionRequest.
func (s *SessionRequest) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts MatchResult to a Tony IR node.
func (s *MatchResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Commit
	irMap["commit"] = ir.FromInt(int64(s.Commit))

	// Field: Body (optional)
	if s.Body != nil {
		irMap["body"] = s.Body
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates MatchResult from a Tony IR node.
func (s *MatchResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for MatchResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "commit":
			// Field: Commit
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "commit", fieldNodeUnwrapped.Type)
			}
			s.Commit = int64(*fieldNodeUnwrapped.Int64)
		case "body":
			if gomap.GetUnmapComments(opts...) {
				s.Body = fieldNode
			} else {
				s.Body = fieldNodeUnwrapped
			}
		}
	}

	return nil
}

// ToTony converts MatchResult to Tony format bytes.
func (s *MatchResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates MatchResult.
func (s *MatchResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts PatchResult to a Tony IR node.
func (s *PatchResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Commit
	irMap["commit"] = ir.FromInt(int64(s.Commit))

	// Field: Data (optional)
	if s.Data != nil {
		irMap["data"] = s.Data
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates PatchResult from a Tony IR node.
func (s *PatchResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for PatchResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "commit":
			// Field: Commit
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "commit", fieldNodeUnwrapped.Type)
			}
			s.Commit = int64(*fieldNodeUnwrapped.Int64)
		case "data":
			if gomap.GetUnmapComments(opts...) {
				s.Data = fieldNode
			} else {
				s.Data = fieldNodeUnwrapped
			}
		}
	}

	return nil
}

// ToTony converts PatchResult to Tony format bytes.
func (s *PatchResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates PatchResult.
func (s *PatchResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts NewTxResult to a Tony IR node.
func (s *NewTxResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: TxID
	irMap["txId"] = ir.FromInt(int64(s.TxID))

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates NewTxResult from a Tony IR node.
func (s *NewTxResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for NewTxResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "txId":
			// Field: TxID
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "txId", fieldNodeUnwrapped.Type)
			}
			s.TxID = int64(*fieldNodeUnwrapped.Int64)
		}
	}

	return nil
}

// ToTony converts NewTxResult to Tony format bytes.
func (s *NewTxResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates NewTxResult.
func (s *NewTxResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts WatchResult to a Tony IR node.
func (s *WatchResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Watching
	irMap["watching"] = ir.FromString(s.Watching)

	// Field: ReplayingTo (optional)
	if s.ReplayingTo != nil {
		irMap["replayingTo"] = ir.FromInt(int64(*s.ReplayingTo))
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates WatchResult from a Tony IR node.
func (s *WatchResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for WatchResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "watching":
			// Field: Watching
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "watching", fieldNodeUnwrapped.Type)
			}
			s.Watching = fieldNodeUnwrapped.String
		case "replayingTo":
			// Field: ReplayingTo
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(int64)
				if fieldNodeUnwrapped.Int64 == nil {
					return fmt.Errorf("%s: expected number, got %v", "field \"replayingTo\"", fieldNodeUnwrapped.Type)
				}
				*val = int64(*fieldNodeUnwrapped.Int64)
				s.ReplayingTo = val
			}
		}
	}

	return nil
}

// ToTony converts WatchResult to Tony format bytes.
func (s *WatchResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates WatchResult.
func (s *WatchResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts UnwatchResult to a Tony IR node.
func (s *UnwatchResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Unwatched
	irMap["unwatched"] = ir.FromString(s.Unwatched)

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates UnwatchResult from a Tony IR node.
func (s *UnwatchResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for UnwatchResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "unwatched":
			// Field: Unwatched
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "unwatched", fieldNodeUnwrapped.Type)
			}
			s.Unwatched = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts UnwatchResult to Tony format bytes.
func (s *UnwatchResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates UnwatchResult.
func (s *UnwatchResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts DeleteScopeResult to a Tony IR node.
func (s *DeleteScopeResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ScopeID
	irMap["scopeId"] = ir.FromString(s.ScopeID)

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates DeleteScopeResult from a Tony IR node.
func (s *DeleteScopeResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for DeleteScopeResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "scopeId":
			// Field: ScopeID
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "scopeId", fieldNodeUnwrapped.Type)
			}
			s.ScopeID = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts DeleteScopeResult to Tony format bytes.
func (s *DeleteScopeResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates DeleteScopeResult.
func (s *DeleteScopeResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts SessionResult to a Tony IR node.
func (s *SessionResult) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Hello (optional)
	if s.Hello != nil {
		node, err = s.Hello.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["hello"] = node
	}

	// Field: Match (optional)
	if s.Match != nil {
		node, err = s.Match.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["match"] = node
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		node, err = s.Patch.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["patch"] = node
	}

	// Field: NewTx (optional)
	if s.NewTx != nil {
		node, err = s.NewTx.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["newtx"] = node
	}

	// Field: Watch (optional)
	if s.Watch != nil {
		node, err = s.Watch.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["watch"] = node
	}

	// Field: Unwatch (optional)
	if s.Unwatch != nil {
		node, err = s.Unwatch.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["unwatch"] = node
	}

	// Field: DeleteScope (optional)
	if s.DeleteScope != nil {
		node, err = s.DeleteScope.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["deleteScope"] = node
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates SessionResult from a Tony IR node.
func (s *SessionResult) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for SessionResult, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "hello":
			// Field: Hello
			s.Hello = &HelloResponse{}
			if err := s.Hello.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "match":
			// Field: Match
			s.Match = &MatchResult{}
			if err := s.Match.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "patch":
			// Field: Patch
			s.Patch = &PatchResult{}
			if err := s.Patch.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "newtx":
			// Field: NewTx
			s.NewTx = &NewTxResult{}
			if err := s.NewTx.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "watch":
			// Field: Watch
			s.Watch = &WatchResult{}
			if err := s.Watch.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "unwatch":
			// Field: Unwatch
			s.Unwatch = &UnwatchResult{}
			if err := s.Unwatch.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "deleteScope":
			// Field: DeleteScope
			s.DeleteScope = &DeleteScopeResult{}
			if err := s.DeleteScope.FromTonyIR(fieldNode); err != nil {
				return err
			}
		}
	}

	return nil
}

// ToTony converts SessionResult to Tony format bytes.
func (s *SessionResult) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates SessionResult.
func (s *SessionResult) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts WatchEvent to a Tony IR node.
func (s *WatchEvent) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Commit
	irMap["commit"] = ir.FromInt(int64(s.Commit))

	// Field: Path
	irMap["path"] = ir.FromString(s.Path)

	// Field: State (optional)
	if s.State != nil {
		irMap["state"] = s.State
	}

	// Field: Patch (optional)
	if s.Patch != nil {
		irMap["patch"] = s.Patch
	}

	// Field: ReplayComplete
	if s.ReplayComplete {
		irMap["replayComplete"] = ir.FromBool(s.ReplayComplete)
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates WatchEvent from a Tony IR node.
func (s *WatchEvent) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for WatchEvent, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "commit":
			// Field: Commit
			if fieldNodeUnwrapped.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "commit", fieldNodeUnwrapped.Type)
			}
			s.Commit = int64(*fieldNodeUnwrapped.Int64)
		case "path":
			// Field: Path
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "path", fieldNodeUnwrapped.Type)
			}
			s.Path = fieldNodeUnwrapped.String
		case "state":
			if gomap.GetUnmapComments(opts...) {
				s.State = fieldNode
			} else {
				s.State = fieldNodeUnwrapped
			}
		case "patch":
			if gomap.GetUnmapComments(opts...) {
				s.Patch = fieldNode
			} else {
				s.Patch = fieldNodeUnwrapped
			}
		case "replayComplete":
			// Field: ReplayComplete
			if fieldNodeUnwrapped.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "replayComplete", fieldNodeUnwrapped.Type)
			}
			s.ReplayComplete = fieldNodeUnwrapped.Bool
		}
	}

	return nil
}

// ToTony converts WatchEvent to Tony format bytes.
func (s *WatchEvent) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates WatchEvent.
func (s *WatchEvent) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts SessionError to a Tony IR node.
func (s *SessionError) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Code
	irMap["code"] = ir.FromString(s.Code)

	// Field: Message
	irMap["message"] = ir.FromString(s.Message)

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates SessionError from a Tony IR node.
func (s *SessionError) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for SessionError, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "code":
			// Field: Code
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "code", fieldNodeUnwrapped.Type)
			}
			s.Code = fieldNodeUnwrapped.String
		case "message":
			// Field: Message
			if fieldNodeUnwrapped.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "message", fieldNodeUnwrapped.Type)
			}
			s.Message = fieldNodeUnwrapped.String
		}
	}

	return nil
}

// ToTony converts SessionError to Tony format bytes.
func (s *SessionError) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates SessionError.
func (s *SessionError) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// ToTonyIR converts SessionResponse to a Tony IR node.
func (s *SessionResponse) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: ID (optional)
	if s.ID != nil {
		irMap["id"] = ir.FromString(*s.ID)
	}

	// Field: Result (optional)
	if s.Result != nil {
		node, err = s.Result.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["result"] = node
	}

	// Field: Event (optional)
	if s.Event != nil {
		node, err = s.Event.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["event"] = node
	}

	// Field: Error (optional)
	if s.Error != nil {
		node, err = s.Error.ToTonyIR()
		if err != nil {
			return nil, err
		}
		irMap["error"] = node
	}

	return ir.FromMap(irMap), nil
}

// FromTonyIR populates SessionResponse from a Tony IR node.
func (s *SessionResponse) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for SessionResponse, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		// Unwrap CommentType for type checking (preserve original for *ir.Node fields)
		fieldNodeUnwrapped := fieldNode
		if fieldNodeUnwrapped.Type == ir.CommentType && len(fieldNodeUnwrapped.Values) > 0 {
			fieldNodeUnwrapped = fieldNodeUnwrapped.Values[0]
		}
		switch fieldName.String {
		case "id":
			// Field: ID
			if fieldNodeUnwrapped.Type == ir.NullType {
				// null value - leave pointer as nil
			} else {
				val := new(string)
				if fieldNodeUnwrapped.Type != ir.StringType {
					return fmt.Errorf("%s: expected string, got %v", "field \"id\"", fieldNodeUnwrapped.Type)
				}
				*val = string(fieldNodeUnwrapped.String)
				s.ID = val
			}
		case "result":
			// Field: Result
			s.Result = &SessionResult{}
			if err := s.Result.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "event":
			// Field: Event
			s.Event = &WatchEvent{}
			if err := s.Event.FromTonyIR(fieldNode); err != nil {
				return err
			}
		case "error":
			// Field: Error
			s.Error = &SessionError{}
			if err := s.Error.FromTonyIR(fieldNode); err != nil {
				return err
			}
		}
	}

	return nil
}

// ToTony converts SessionResponse to Tony format bytes.
func (s *SessionResponse) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates SessionResponse.
func (s *SessionResponse) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}
