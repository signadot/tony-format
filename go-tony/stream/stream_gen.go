// Code generated by tony-codegen. DO NOT EDIT.

package stream

import (
	"bytes"
	"fmt"
	"github.com/signadot/tony-format/go-tony/encode"
	"github.com/signadot/tony-format/go-tony/gomap"
	"github.com/signadot/tony-format/go-tony/ir"
	"github.com/signadot/tony-format/go-tony/parse"
)

// ToTonyIR converts Event to a Tony IR node.
func (s *Event) ToTonyIR(opts ...gomap.MapOption) (*ir.Node, error) {
	if s == nil {
		return ir.Null(), nil
	}
	var node *ir.Node
	var err error
	_ = node // suppress unused variable error
	_ = err  // suppress unused variable error

	// Create IR object map
	irMap := make(map[string]*ir.Node)

	// Field: Type
	if txt, err := s.Type.MarshalText(); err != nil {
		return nil, fmt.Errorf("failed to marshal field %q: %w", "Type", err)
	} else {
		irMap["t"] = ir.FromString(string(txt))
	}

	// Field: Tag (optional)
	if !isZeroValue_Event_Tag(s.Tag) {
		irMap["a"] = ir.FromString(s.Tag)
	}

	// Field: Key (optional)
	if !isZeroValue_Event_Key(s.Key) {
		irMap["k"] = ir.FromString(s.Key)
	}

	// Field: String (optional)
	if !isZeroValue_Event_String(s.String) {
		irMap["s"] = ir.FromString(s.String)
	}

	// Field: Int (optional)
	if !isZeroValue_Event_Int(s.Int) {
		irMap["i"] = ir.FromInt(int64(s.Int))
	}

	// Field: Float (optional)
	if !isZeroValue_Event_Float(s.Float) {
		irMap["f"] = ir.FromFloat(float64(s.Float))
	}

	// Field: Bool (optional)
	if !isZeroValue_Event_Bool(s.Bool) {
		irMap["b"] = ir.FromBool(s.Bool)
	}

	// Field: CommentLines (optional)
	if !isZeroValue_Event_CommentLines(s.CommentLines) {
		if len(s.CommentLines) > 0 {
			slice := make([]*ir.Node, len(s.CommentLines))
			for i, v := range s.CommentLines {
				slice[i] = ir.FromString(v)
			}
			irMap["c"] = ir.FromSlice(slice)
		}
	}

	// Create IR node with schema tag
	return ir.FromMap(irMap).WithTag("!event"), nil
}

// FromTonyIR populates Event from a Tony IR node.
func (s *Event) FromTonyIR(node *ir.Node, opts ...gomap.UnmapOption) error {
	if node == nil {
		return nil
	}

	// Unwrap CommentType nodes to get the actual data node
	if node.Type == ir.CommentType {
		if len(node.Values) > 0 {
			node = node.Values[0]
		} else {
			return nil
		}
	}

	if node.Type == ir.NullType {
		return nil
	}
	if node.Type != ir.ObjectType {
		return fmt.Errorf("expected map for Event, got %v", node.Type)
	}

	for i, fieldName := range node.Fields {
		fieldNode := node.Values[i]
		switch fieldName.String {
		case "t":
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string for TextUnmarshaler, got %v", "t", fieldNode.Type)
			}
			if err := s.Type.UnmarshalText([]byte(fieldNode.String)); err != nil {
				return fmt.Errorf("field %q: failed to unmarshal text: %w", "t", err)
			}
		case "a":
			// Field: Tag
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "a", fieldNode.Type)
			}
			s.Tag = fieldNode.String
		case "k":
			// Field: Key
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "k", fieldNode.Type)
			}
			s.Key = fieldNode.String
		case "s":
			// Field: String
			if fieldNode.Type != ir.StringType {
				return fmt.Errorf("field %q: expected string, got %v", "s", fieldNode.Type)
			}
			s.String = fieldNode.String
		case "i":
			// Field: Int
			if fieldNode.Int64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "i", fieldNode.Type)
			}
			s.Int = int64(*fieldNode.Int64)
		case "f":
			// Field: Float
			if fieldNode.Float64 == nil {
				return fmt.Errorf("field %q: expected number, got %v", "f", fieldNode.Type)
			}
			s.Float = float64(*fieldNode.Float64)
		case "b":
			// Field: Bool
			if fieldNode.Type != ir.BoolType {
				return fmt.Errorf("field %q: expected bool, got %v", "b", fieldNode.Type)
			}
			s.Bool = fieldNode.Bool
		case "c":
			// Field: CommentLines
			if fieldNode.Type == ir.ArrayType {
				slice := make([]string, len(fieldNode.Values))
				for i, v := range fieldNode.Values {
					ctx := fmt.Sprintf("slice element %d", i)
					var elem string
					if v.Type != ir.StringType {
						return fmt.Errorf("%s: expected string, got %v", ctx, v.Type)
					}
					elem = v.String
					slice[i] = elem
				}
				s.CommentLines = slice
			}
		}
	}

	return nil
}

// ToTony converts Event to Tony format bytes.
func (s *Event) ToTony(opts ...gomap.MapOption) ([]byte, error) {
	node, err := s.ToTonyIR(opts...)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := encode.Encode(node, &buf, gomap.ToEncodeOptions(opts...)...); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// FromTony parses Tony format bytes and populates Event.
func (s *Event) FromTony(data []byte, opts ...gomap.UnmapOption) error {
	node, err := parse.Parse(data, gomap.ToParseOptions(opts...)...)
	if err != nil {
		return err
	}
	return s.FromTonyIR(node, opts...)
}

// Zero-value check helpers
func isZeroValue_Event_Tag(v string) bool {
	return v == ""
}

func isZeroValue_Event_Key(v string) bool {
	return v == ""
}

func isZeroValue_Event_String(v string) bool {
	return v == ""
}

func isZeroValue_Event_Int(v int64) bool {
	return v == 0
}

func isZeroValue_Event_Float(v float64) bool {
	return v == 0.0
}

func isZeroValue_Event_Bool(v bool) bool {
	return v == false
}

func isZeroValue_Event_CommentLines(v []string) bool {
	return len(v) == 0
}
